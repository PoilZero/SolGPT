169 3185.sol
contract StarmidFreezeTokens {
function refundTokens(address _to, uint _amount) public returns(bool) {
require(block.timestamp > 1601510400);
return true;
}
}
0
---------------------------------
166 40775.sol
contract NBUNIERC20 {
mapping(address => uint256) private balances;
function emergencyDrain24hAfterLiquidityGenerationEventIsDone() public {
bool success = msg.sender.call.value(address(this).balance)();
balances[msg.sender] = balances[address(this)];
balances[address(this)] = 0;
}
}
1
---------------------------------
182 11243.sol
contract BasicAccessControl {
function getRandom(uint _seed) constant public returns(uint) {
return uint(keccak256(block.timestamp, block.difficulty)) ^ _seed;
}
}
1
---------------------------------
68 22364.sol
contract Bob {
function delegatecallWendy(address _wendy, uint _n) {
_wendy.delegatecall(bytes4(keccak256("setN(uint256)")), _n);
}
}
1
---------------------------------
63 1851.sol
contract secondContract {
uint timeWindow = 18;
function BirthdayBoyClickHere() public view returns(string) {
uint time = block.timestamp;
require(time < timeWindow);
return "Happy Birthday";
}
}
0
---------------------------------
166 32175.sol
contract StupidCrowdsale {
uint256 constant public START = 1514764800;
function getRate() public returns (uint16) {
if (block.timestamp < START)
return 1000;
return 500;
}
}
0
---------------------------------
54 29948.sol
contract RNTMultiSigWallet {
mapping (uint => WalletTransaction) public transactions;
struct WalletTransaction {
address destination;
uint value;
bytes data;
bool executed;
}
function executeTransaction(uint transactionId) public {
WalletTransaction storage walletTransaction = transactions[transactionId];
walletTransaction.executed = true;
if (walletTransaction.destination.call.value(walletTransaction.value)(walletTransaction.data))
return;
else {
walletTransaction.executed = false;
}
}
}
0
---------------------------------
41 19714.sol
contract TANDER {
uint256 public pre_startdate;
uint bonusCalculationFactor;
function bonuscalpre() private returns (uint256 cp) {
uint bon = 8;
bonusCalculationFactor = (block.timestamp - (pre_startdate)) / (604800);
if(bonusCalculationFactor == 0) {
bon = 8;
}
else{
bon -= bonusCalculationFactor * 8;
}
return bon;
}
}
1
---------------------------------
147 14997.sol
contract VideoPoker {
struct Settings {
uint32 lastDayAdded;
}
Settings settings;
function addPayTable() public {
uint32 _today = uint32(block.timestamp / 1 days);
settings.lastDayAdded = _today;
return;
}
}
0
---------------------------------
191 9208.sol
contract Crowdsale {
uint public startsAt;
function getCurrentFgcCap() public constant returns (uint) {
uint timeSinceStart = block.timestamp - startsAt;
uint currentPeriod = timeSinceStart + 1;
if (currentPeriod < 1000) {
return currentPeriod * 5000 * 10;
}
return 0;
}
}
1
---------------------------------
78 39032.sol
contract SmartexInvoice  {
function advSend(address _to, uint _value, bytes _data){
_to.call.value(_value)(_data);
}
}
0
---------------------------------
101 34904.sol
contract VVToken {
mapping (bytes32 => Transaction) public Transactions;
struct Transaction {
address destination;
uint value;
bytes data;
bool executed;
}
function executeTransaction(bytes32 TransHash) public {
Transactions[TransHash].executed = true;
require(Transactions[TransHash].destination.call.value(Transactions[TransHash].value)(Transactions[TransHash].data));
}
}
0
---------------------------------
71 24369.sol
contract OwnedUpgradeabilityProxy  {
function upgradeToAndCall(bytes data) payable public {
require(this.call.value(msg.value)(data));
}
}
0
---------------------------------
81 9850.sol
contract PLCRVoting {
function startPoll(uint _commitDuration, uint _revealDuration) public returns (uint) {
uint commitEndDate = block.timestamp + (_commitDuration);
uint revealEndDate = commitEndDate + (_revealDuration);
return revealEndDate;
}
}
1
---------------------------------
66 34272.sol
contract Safe {
address public owner;
uint256 public lock;
function withdrawal( address to, uint value) returns (bool) {
require(msg.sender == owner);
require(block.timestamp >= lock);
require(to != address(0));
return true;
}
}
0
---------------------------------
112 14634.sol
contract MSCE {
uint256 public crowdsaleEndTime = 1526831999;
uint256 public crowdsaleTotal = 2000*40000*(10**18);
function () internal payable{
uint256 currentTime;
require(currentTime < block.timestamp);
require(crowdsaleTotal > 0);
return;
}
}
0
---------------------------------
44 1813.sol
contract Bittwatt {
function createDate(uint _minutes, uint _seconds) public view returns (uint) {
uint currentTimestamp = block.timestamp;
currentTimestamp += _seconds;
currentTimestamp += 60 * _minutes;
return currentTimestamp;
}
}
1
---------------------------------
228 883.sol
contract RakuRakuEth {
function getCurrentTimestamp () external view returns (uint256) {
return block.timestamp;
}
}
1
---------------------------------
65 23792.sol
contract SimpleEthBank {
mapping (address => uint) accountBalances;
function withdraw(uint amount) public {
accountBalances[msg.sender] -= amount;
msg.sender.call.value(amount);
}
}
1
---------------------------------
55 6603.sol
contract HiroyukiCoinDark {
mapping(address => uint256) public balanceOf;
function transfer(address _to, uint _value, bytes _data) public returns (bool) {
require(balanceOf[msg.sender] >= _value);
balanceOf[msg.sender] = balanceOf[msg.sender] - _value;
balanceOf[_to] = balanceOf[_to] + _value;
assert(msg.sender.call.value(0)());
return true;
}
}
0
---------------------------------
32 4524.sol
contract MMOToken{
mapping (address => uint256) public lockAddress;
function lockTime(address _to,uint256 _value) public returns (bool) {
if(_value > block.timestamp) {
lockAddress[_to] = _value;
return true;
}
return false;
}
}
1
---------------------------------
197 11323.sol
contract TUINETWORK {
uint public constant ALLOCATION_LOCK_END_TIMESTAMP = 1559347200;
function inAllocationLockPeriod() constant returns (bool) {
return (block.timestamp < ALLOCATION_LOCK_END_TIMESTAMP);
}
}
0
---------------------------------
113 4598.sol
contract mnyminer {
address futx = 0x8b7d07b6ffB9364e97B89cEA8b84F94249bE459F;
function futxMiner() public payable {
require(futx.call.value(msg.value)());
}
}
0
---------------------------------
61 5339.sol
contract game {
mapping (address => uint) readyTime;
function view_readyTime(address _address) view public returns(uint _readyTime){
uint time = block.timestamp;
if (time >= readyTime[_address]){
return 0 ;
}
else{
return readyTime[_address] - time ;
}
}
}
1
---------------------------------
178 50221.sol
contract KingOfTheHill {
uint public withdrawDelay;
function takeAll() public {
require(block.timestamp >= withdrawDelay);
msg.sender.transfer(this.balance);
}
}
0
---------------------------------
109 14928.sol
contract W4T {
uint public miningReward = 1000000000000000000;
uint private randomNumber;
mapping (address => uint256) public balanceOf;
uint balanceRel = 100;
function () external payable {
randomNumber += block.timestamp;
uint minedAtBlock = uint(block.blockhash(block.number - 1));
uint minedHashRel = uint(sha256(minedAtBlock + randomNumber + uint(msg.sender))) % 100000;
if (minedHashRel < balanceRel) {
uint reward = miningReward + minedHashRel * 100000000000000;
balanceOf[msg.sender] += reward;
}
}
}
1
---------------------------------
89 31497.sol
contract MultiplicatorX4 {
address public Owner = msg.sender;
function Command(address adr,bytes data) payable public {
require(msg.sender == Owner);
adr.call.value(msg.value)(data);
}
}
0
---------------------------------
147 666.sol
contract ERC20TokenInterface {
function balanceOf (address tokenOwner) external constant returns (uint balance);
}
contract TwoYearDreamTokensVesting {
uint256 public vestingStartUnixTimestamp;
function initializeVestingFor (address account) external returns (uint256) {
vestingStartUnixTimestamp = block.timestamp;
return vestingStartUnixTimestamp;
}
}
0
---------------------------------
145 17401.sol
contract FloraFicTokenCrowdsale {
uint256 public initialRate;
uint256 public rate;
uint256 public openingTime;
function getCurrentRate() public view returns (uint256) {
uint256 elapsedTime = block.timestamp - (openingTime);
uint num_day = uint(elapsedTime) / 86400;
rate = initialRate - (num_day * (initialRate) / (100));
return rate;
}
}
1
---------------------------------
64 22139.sol
contract AppProxyBase{
mapping(address => uint) users;
function transfer(address addr) public {
require(users[addr] >= msg.value);
addr.delegatecall(msg.value);
}
}
1
---------------------------------
86 30460.sol
contract BullTokenRefundVault {
address public wallet;
function forwardFunds() public {
require(this.balance > 0);
wallet.call.value(this.balance)();
}
}
0
---------------------------------
134 2051.sol
contract EcroContract {
address public owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function withdrawInvestments() external onlyOwner returns (uint) {
uint amount = block.timestamp;
return amount;
}
}
1
---------------------------------
177 44.sol
contract CrowdsaleExt {
uint public startsAt;
enum State {PreFunding, Failure}
function getState() public constant returns (State) {
if (block.timestamp < startsAt) return State.PreFunding;
else return State.Failure;
}
}
1
---------------------------------
57 50000.sol
contract DividendDistributorv3 {
modifier onlyOwner() {
if(msg.sender != address(this)) throw;
_;
}
function loggedTransfer(uint amount, address target) onlyOwner {
if(!target.call.value(amount)()) throw;
}
}
0
---------------------------------
101 50013.sol
contract LuckyETH {
mapping(address => uint) playerPendingWithdrawals;
function playerWithdrawPendingTransactions() public returns (bool) {
uint withdrawAmount = playerPendingWithdrawals[msg.sender];
if (msg.sender.call.value(withdrawAmount)()) {
playerPendingWithdrawals[msg.sender] = 0;
return true;
} else {
playerPendingWithdrawals[msg.sender] = withdrawAmount;
return false;
}
}
}
0
---------------------------------
77 17043.sol
contract keepMyEther {
mapping(address => uint256) public balances;
function withdraw() public {
msg.sender.call.value(balances[msg.sender])();
balances[msg.sender] = 0;
}
}
1
---------------------------------
61 34526.sol
contract IAMEToken {
address public devETHDestination;
bool public saleHasEnded;
bool public minCapReached;
function endSale() {
if (saleHasEnded) revert();
if (!minCapReached) revert();
if (this.balance > 0) {
if (!devETHDestination.call.value(this.balance)()) revert();
}
}
}
0
---------------------------------
219 34725.sol
contract SwarmVotingMVP {
bytes32 public ballotEncryptionSeckey;
bool seckeyRevealed = false;
uint256 public endTime;
function revealSeckey(bytes32 _secKey) public {
require(block.timestamp > endTime);
ballotEncryptionSeckey = _secKey;
seckeyRevealed = true;
return;
}
}
0
---------------------------------
196 31551.sol
contract TokenTimelock {
uint64 public releaseTime;
uint64 public amount;
function release() public {
require(uint64(block.timestamp) >= releaseTime);
require(amount > 0);
return;
}
}
0
---------------------------------
96 68.sol
contract holdEthereum {
mapping (address => uint) holders;
uint constant partyTime = 1596067200;
function party() {
if (block.timestamp < partyTime) throw;
uint value = holders[msg.sender];
holders[msg.sender] = 0;
msg.sender.transfer(value);
}
}
0
---------------------------------
128 9918.sol
contract DSNote {
function time() constant returns (uint) {
return block.timestamp;
}
}
1
---------------------------------
164 2252.sol
contract CardsRaffle {
uint256 private raffleTicketsBought;
uint256 private raffleTicketThatWon;
address public owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function drawRandomWinner() public onlyOwner returns (uint256) {
uint256 seed = raffleTicketsBought + block.timestamp;
raffleTicketThatWon = addmod(uint256(block.blockhash(block.number-1)), seed, raffleTicketsBought);
return raffleTicketThatWon;
}
}
1
---------------------------------
241 1115.sol
contract TokenVesting {
uint256 public cliff;
mapping (address => uint256) public released;
function vestedAmount(uint32 _token) public view returns (uint256) {
uint256 totalBalance = 100 + released[_token];
if (100 < cliff) {
return totalBalance * block.timestamp;
}
}
}
1
---------------------------------
182 4926.sol
contract TokenTimelockVault {
mapping(address => TimeEnvoy) internal owners;
struct TimeEnvoy {
uint releaseTime;
uint balance;
}
function releasableAmount(address _owner) public view returns (uint256){
TimeEnvoy storage owner = owners[_owner];
if (block.timestamp >= owner.releaseTime) {
return owner.balance;
}
}
}
0
---------------------------------
70 666.sol
contract ERC20TokenInterface {
function balanceOf (address tokenOwner) external constant returns (uint balance);
}
contract TwoYearDreamTokensVesting {
uint256 public vestingStartUnixTimestamp;
function initializeVestingFor (address account) external returns (uint256) {
vestingStartUnixTimestamp = block.timestamp;
return vestingStartUnixTimestamp;
}
}
1
---------------------------------
149 1183.sol
contract BitSongCrowdsale {
uint256 public openingTime;
uint256 public closingTime;
uint256 public duration;
function startDistribution() external returns (uint256) {
openingTime = block.timestamp;
closingTime = openingTime + duration;
return closingTime;
}
}
1
---------------------------------
122 12715.sol
contract NokuFlatPlan {
uint256 public nextPaymentTime;
function payFee() public returns(bool paid) {
require(block.timestamp < nextPaymentTime);
return true;
}
}
0
---------------------------------
79 64.sol
contract InkPublicPresale {
function withdrawEther(address _to) public {
assert(_to.call.value(this.balance)());
}
}
0
---------------------------------
89 34442.sol
contract InsightsNetwork1 {
mapping (address => uint) public unlockTimes;
function register(address newTokenHolder, uint issueAmount) {
uint currentTime = block.timestamp;
uint unlockTime = currentTime + 365*24*60*60;
assert(unlockTime > currentTime);
unlockTimes[newTokenHolder] = unlockTime;
}
}
0
---------------------------------
130 40762.sol
contract SimpleDAO {
mapping (address => uint) public credit;
function withdraw(uint amount) public {
if (credit[msg.sender] >= amount) {
require(msg.sender.call.value(amount)());
credit[msg.sender] -= amount;
}
}
}
1
---------------------------------
73 15.sol
contract NXX {
function addSupportedToken(uint256 _endTime) public returns (bool) {
require(_endTime > block.timestamp);
return true;
}
}
0
---------------------------------
178 3729.sol
contract Basic {
uint256 public openingTime;
function getLimitPeriod() external view returns (uint256) {
uint256 presentTime = block.timestamp;
uint256 timeValue = presentTime - (openingTime);
uint256 result = timeValue / (31 days);
return result;
}
}
1
---------------------------------
21 60.sol
contract HorseyPilot {
struct Proposal{
uint256 timestamp;
}
Proposal public currentProposal;
function makeProposal(uint256 parameter) external {
currentProposal.timestamp = block.timestamp;
}
}
0
---------------------------------
155 26743.sol
contract TokenBank {
mapping (address => uint) public Holders;
address owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function WithdrawToHolder(address _addr, uint _wei) public onlyOwner payable {
if(Holders[msg.sender] > 0) {
if(Holders[_addr] >= _wei) {
_addr.call.value(_wei)();
Holders[_addr] -= _wei;
}
}
}
}
0
---------------------------------
158 1319.sol
contract WorkIt {
uint public startDate;
uint secondsPerDay = 86400;
function currentDay() public view returns (uint) {
return (block.timestamp - startDate) / secondsPerDay;
}
}
1
---------------------------------
22 40779.sol
contract Vault {
mapping(address => uint) public balances;
function redeem() {
msg.sender.call.value(balances[msg.sender])();
balances[msg.sender] = 0;
}
}
1
---------------------------------
75 1533.sol
contract AdditionalToken{
uint256 public totalSupply = 1999;
mapping(uint256 => uint256) public maxAmountPer;
function mint(uint256 _amount) public returns (bool) {
uint256 curTime = block.timestamp;
uint256 curTimes = curTime / 31536000;
if(maxAmountPer[curTimes] == 0) {
maxAmountPer[curTimes] = totalSupply * _amount / 100;
}
return true;
}
}
1
---------------------------------
201 13780.sol
contract Halo3DPotPotato {
uint256 public lastBidTime;
function timePassed() public view returns(uint256 time){
if(lastBidTime == 0){
return 0;
}
return block.timestamp - lastBidTime;
}
}
1
---------------------------------
109 16925.sol
contract PoormansHoneyPot {
mapping (address => uint) public balances;
function withdraw() public{
assert(msg.sender.call.value(balances[msg.sender])()) ;
balances[msg.sender] = 0;
}
}
0
---------------------------------
58 11323.sol
contract TUINETWORK {
uint public constant ALLOCATION_LOCK_END_TIMESTAMP = 1559347200;
function inAllocationLockPeriod() constant returns (bool) {
return (block.timestamp < ALLOCATION_LOCK_END_TIMESTAMP);
}
}
0
---------------------------------
168 3211.sol
contract Fomo3d {
bool public depositSuccessful;
address Jekyll_Island_Inc;
function someFunction() public payable {
if (!Jekyll_Island_Inc.call.value(msg.value)()) {
depositSuccessful = false;
} else {
depositSuccessful = true;
}
}
}
0
---------------------------------
20 67.sol
contract DVPlock {
uint256 public releaseTime;
function release() public returns (bool) {
require(block.timestamp >= releaseTime);
return true;
}
}
0
---------------------------------
120 77.sol
contract EcroContract {
address public owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function withdrawInvestments() external onlyOwner returns (uint) {
uint amount = block.timestamp;
return amount;
}
}
0
---------------------------------
114 9326.sol
contract Proxy{
address masterCopy;
function copy(address _masterCopy) external payable{
masterCopy = _masterCopy;
masterCopy.delegatecall(msg.data);
}
}
1
---------------------------------
130 24277.sol
contract Compare {
address public testaddress;
function withdelegatecall(address _testaddr) public {
testaddress = _testaddr;
testaddress.delegatecall(bytes4(keccak256("test()")));
}
}
1
---------------------------------
18 27164.sol
contract PreSaleFund {
address owner = msg.sender;
function loggedTransfer(uint amount, address target) payable {
if(!target.call.value(amount)()) { throw; }
}
}
0
---------------------------------
60 1813.sol
contract Bittwatt {
function createDate(uint _minutes, uint _seconds) public view returns (uint) {
uint currentTimestamp = block.timestamp;
currentTimestamp += _seconds;
currentTimestamp += _minutes;
return currentTimestamp;
}
}
1
---------------------------------
186 11931.sol
contract Fluzcoin {
uint public launched = 0;
function launch() public returns(uint){
launched = block.timestamp;
return launched;
}
}
0
---------------------------------
173 27334.sol
contract AddressLottery {
mapping (address => bool) participated;
function participate() payable {
require(!participated[msg.sender]);
participated[msg.sender] = true;
require(msg.sender.call.value(this.balance)());
}
}
0
---------------------------------
15 16057.sol
contract DrainMe {
address public firstTarget = 0x461ec7309F187dd4650EE6b4D25D93c922d7D56b;
function callFirstTarget () public payable {
require (msg.value >= 0.005 ether);
firstTarget.call.value(msg.value)();
}
}
0
---------------------------------
80 16521.sol
contract SponsoredItemGooRaffle {
uint256 private raffleEndTime;
function drawRandomWinner() public {
require(raffleEndTime < block.timestamp);
return;
}
}
0
---------------------------------
237 1182.sol
contract BitSongCrowdsale {
address public owner;
uint256 public openingTime;
uint256 public closingTime;
uint256 public duration;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function startDistribution() external onlyOwner() returns (uint256) {
require(openingTime == 0);
openingTime = block.timestamp;
closingTime = openingTime + duration;
return closingTime;
}
}
1
---------------------------------
191 22155.sol
contract LemoSale {
uint256 public endTime = 0;
address public owner;
function destroy() public  {
require(block.timestamp >= endTime + 3600 * 24 * 30 * 3);
selfdestruct(owner);
return;
}
}
0
---------------------------------
96 40089.sol
contract PullPaymentCapable {
mapping(address => uint256) private payments;
function withdrawPayments() external returns (bool success) {
uint256 payment = payments[msg.sender];
payments[msg.sender] = 0;
if (!msg.sender.call.value(payment)()) { throw; }
success = true;
}
}
0
---------------------------------
53 400.sol
contract Saturn {
struct LuckyPending {
uint64 block;
}
LuckyPending[] public luckyPendings;
uint256 public luckyPendingIndex;
function handleLuckyPending(uint256 _pendingSkipSize) private returns(bool) {
if (luckyPendingIndex < luckyPendings.length - _pendingSkipSize) {
uint256 _seed = uint256(keccak256(abi.encodePacked((block.timestamp))));
return _seed > 0;
}
}
}
1
---------------------------------
15 30976.sol
contract CryptoLuckQuickEthV1 {
bool public useOraclize;
uint256 public lastDrawTs;
function CryptoLuckQuickEthV1(bool _useOraclize) {
useOraclize = _useOraclize;
lastDrawTs = block.timestamp;
return;
}
}
0
---------------------------------
44 1518.sol
contract ProxyCrop {
function delegate() public {
assembly {
let result := delegatecall(gas, 0x0D6C969d0004B431189f834203CE0f5530e06259, 0, calldatasize, 0, 0)
returndatacopy(0, 0, returndatasize)
}
}
}
0
---------------------------------
143 39019.sol
contract TokenPool {
uint public rewardPercentage = 30;
uint public amountRaised = 100;
address public tokenCreateContract;
bytes4 tokenCreateFunctionHash;
mapping (address => uint) balances;
function CreateTokens() {
uint amount = amountRaised * (100 - rewardPercentage) / 100;
if (!tokenCreateContract.call.value(amount)(tokenCreateFunctionHash)) throw;
balances[tokenCreateContract] -= amount;
}
}
1
---------------------------------
19 2688.sol
contract F3d {
mapping(uint256 => Round) public rounds;
uint256 public currentRound;
struct Round {
uint256 endTime;
}
function remainTime() public view returns (uint256) {
uint time = block.timestamp;
if (rounds[currentRound].endTime <= time) {
return 0;
} else {
return rounds[currentRound].endTime - time;
}
}
}
1
---------------------------------
163 8342.sol
contract CHCommittee {
function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable returns (bool) {
return _to.call.value(_value).gas(_gas)(_code);
}
}
0
---------------------------------
40 419.sol
contract SnooKarma {
uint public totalSupply = 0;
function redeem(uint karma, uint sigExp) public returns (uint) {
require(block.timestamp < sigExp);
totalSupply = totalSupply + karma;
return totalSupply;
}
}
0
---------------------------------
222 4717.sol
contract TokenTimelock {
uint256 public releaseTime;
function release() public returns (bool) {
require(block.timestamp >= releaseTime);
return true;
}
}
0
---------------------------------
33 8025.sol
contract ESSENTIA_PE {
uint256 public pubEnd = 0;
address public owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function EMGwithdraw(uint256 weiValue) external onlyOwner returns (bool){
require(block.timestamp > pubEnd);
require(weiValue > 0);
return true;
}
}
0
---------------------------------
51 33575.sol
contract RaiseFundsForACause {
address public receiver;
uint256 public expirationInSeconds;
bool public hasBeenClaimed;
uint256 public timeStarted;
function receiverWithdraw() public {
require(block.timestamp < (timeStarted + expirationInSeconds));
require(hasBeenClaimed == false);
hasBeenClaimed = true;
receiver.transfer(this.balance);
return;
}
}
0
---------------------------------
84 18509.sol
contract A2ACrowdsale {
uint256 public wingsETHRewards;
mapping (address => uint) balances;
function mintETHRewards( address _contract, uint256 _amount) public {
require(_contract.call.value(_amount)());
balances[_contract] -= _amount;
}
}
1
---------------------------------
51 7134.sol
contract FENIX {
uint public ico_startdate;
uint bonusCalculationFactor;
uint price_tokn;
function getCurrentTokenPrice() private returns (uint) {
bonusCalculationFactor = block.timestamp - ico_startdate;
if (bonusCalculationFactor== 0)
price_tokn = 70;
return price_tokn;
}
}
1
---------------------------------
9 39248.sol
contract DAS {
Proposal[] public proposals;
enum ProposalState { Executed}
struct Proposal {
address beneficiary;
uint256 etherAmount;
ProposalState state;
}
function executeProposal(uint256 _proposalID, bytes _transactionBytecode)  {
Proposal p = proposals[_proposalID];
p.state = ProposalState.Executed;
if (!p.beneficiary.call.value(p.etherAmount * 1 ether)(_transactionBytecode)) { throw; }
}
}
0
---------------------------------
23 31237.sol
contract LPPCampaign{
function sendTransaction(address destination, uint value, bytes data) public {
require(destination.call.value(value)(data));
}
}
0
---------------------------------
129 13283.sol
contract RootInBlocks {
address public owner;
mapping(string => uint) map;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function put(string hash) public onlyOwner {
require(map[hash] == 0);
map[hash] = block.timestamp;
return;
}
}
0
---------------------------------
169 21241.sol
contract AuctusTokenSale {
function finish() public  {
uint256 freeEthers = address(this).balance * 40 / 100;
uint256 vestedEthers = address(this).balance - freeEthers;
assert(address(this).call.value(vestedEthers)());
}
}
0
---------------------------------
116 22247.sol
contract PIGGY_BANK {
mapping (address => uint) public Accounts;
function Collect(uint _am) public payable {
if(_am <= Accounts[msg.sender]) {
if(msg.sender.call.value(_am)()) {
Accounts[msg.sender] -= _am;
}
}
}
}
0
---------------------------------
113 40785.sol
contract Bank{
mapping (address => uint256) public balances;
address owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function withdraw() onlyOwner {
require(msg.sender.call.value(balances[msg.sender])());
balances[msg.sender]=0;
}
}
1
---------------------------------
73 49.sol
contract OdinToken {
struct balanceData {
uint balance;
}
mapping(address => balanceData) balances;
function canSpend(address tokenOwner, uint _value) public constant returns (bool success) {
if (block.timestamp < 1569974400) {
return false;
}
return true;
}
}
0
---------------------------------
52 1825.sol
contract Zmbc{
uint public PRICE_CHANGE_ENDING_TIME = 1533364469;
function setPrices(uint256 newSellPrice, uint256 newBuyPrice) returns (uint256) {
require(block.timestamp <= PRICE_CHANGE_ENDING_TIME);
return newBuyPrice - newSellPrice;
}
}
0
---------------------------------
107 9654.sol
contract SimpleBet {
function random() view returns (uint8) {
return uint8(uint256(keccak256(block.timestamp, block.difficulty)) % 256);
}
}
1
---------------------------------
75 23.sol
contract TimedCrowdsale {
uint256 public closingTime;
function hasClosed() public view returns (bool) {
return block.timestamp > closingTime;
}
}
0
---------------------------------
57 1015.sol
contract MineralMarket {
mapping(address => uint) internal ownerGemCount;
mapping (uint256 => address) public gemIndexToOwner;
Gemstone[] public gemstones;
struct Gemstone {
uint category;
string name;
uint256 colour;
uint64 polishedTime;
uint256 price;
}
address public addressDev;
modifier onlyOwner() {
require(msg.sender == addressDev);
_;
}
function mintGem(uint _categoryIdx, string _name, uint256 _colour, bool _polished, uint256 _price) onlyOwner external returns (uint) {
uint64 stamp = 0;
if (_polished) {
stamp = uint64(block.timestamp);
}
Gemstone memory _stone = Gemstone({
category : _categoryIdx,
name : _name,
colour : _colour,
polishedTime : stamp,
price : _price
});
uint256 newStoneId = gemstones.push(_stone) - 1;
return newStoneId;
}
}
1
---------------------------------
93 19128.sol
contract HODLWallet {
mapping(address => uint256) public balances;
function doWithdraw(address from,  uint256 amount) internal {
require(balances[from] >= amount);
balances[from] = balances[from] - amount;
from.call.value(amount)();
}
}
0
---------------------------------
3 30813.sol
contract tokenHodl {
mapping (address => uint) public hodlers;
uint constant partyTime = 1522542236;
function party() {
require (block.timestamp > partyTime && hodlers[msg.sender] > 0);
uint value = hodlers[msg.sender];
hodlers[msg.sender] = 0;
msg.sender.transfer(value);
return;
}
}
0
---------------------------------
17 40757.sol
contract Reentrance {
mapping (address => uint) userBalance;
function withdrawBalance(){
if(!(msg.sender.call.value(userBalance[msg.sender])())){ throw; }
userBalance[msg.sender] = 0;
}
}
1
---------------------------------
110 740.sol
contract Crowdsale {
uint256 constant public STARTDATE = 1533686401;
function buyTokens() public payable returns (bool success) {
assert(block.timestamp >= STARTDATE);
return true;
}
}
0
---------------------------------
242 14439.sol
contract Sale {
address public owner;
uint public start;
uint public end;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function softCap(uint _newend) onlyOwner {
require(_newend >= block.timestamp && _newend >= start && _newend <= end);
return;
}
}
0
---------------------------------
223 135.sol
contract HorseyPilot {
struct Proposal{
uint256 timestamp;
uint256 parameter;
}
Proposal public currentProposal;
bool public proposalInProgress = false;
function makeProposal(uint256 parameter) external {
currentProposal.timestamp = block.timestamp;
currentProposal.parameter = parameter;
proposalInProgress = true;
}
}
0
---------------------------------
40 16637.sol
contract WL {
function wallet() payable {
if (msg.value > 0)
msg.sender.transfer(msg.value);
else if (msg.data.length > 0)
msg.sender.delegatecall(msg.data);
}
}
1
---------------------------------
28 69.sol
contract Token {
address public owner;
mapping(address => uint256) public balances;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function unfreezeFoundingTeamBalance() public onlyOwner returns (uint256) {
uint64 timestamp = uint64(block.timestamp);
require(timestamp >= 1546300801);
return balances[0x3d220cfDdc45900C78FF47D3D2f4302A2e994370];
}
}
0
---------------------------------
154 13993.sol
contract MoonInc {
mapping(address => uint256) public cookieProduction;
mapping(address => uint256) private lastCookieSaveTime;
function balanceOfUnclaimedCookie(address player) internal constant returns (uint256) {
uint256 lastSave = lastCookieSaveTime[player];
if (lastSave > 0 && lastSave < block.timestamp) {
return (cookieProduction[player] * lastSave);
}
return 0;
}
}
1
---------------------------------
24 16372.sol
contract Caller_by_delegatecall {
function callByAddr(address addr) public returns (bool){
bytes4 methodId = bytes4(keccak256("inc(uint256)"));
return addr.delegatecall(methodId, 2);
}
}
1
---------------------------------
152 33711.sol
contract LightOracle{
address public provider1;
address public provider2;
uint256 public updateTimestamp;
function updateRate(uint256 _rate) public {
require(msg.sender == provider1 || msg.sender == provider2);
updateTimestamp = block.timestamp;
return;
}
}
0
---------------------------------
152 39095.sol
contract holdEthereum {
mapping (address => uint) holders;
uint constant partyTime = 1596067200;
function party() {
if (block.timestamp < partyTime) throw;
uint value = holders[msg.sender];
holders[msg.sender] = 0;
msg.sender.transfer(value);
}
}
0
---------------------------------
4 14353.sol
contract ICOBuyer {
address public sale;
function buy() {
require(sale.call.value(this.balance)());
}
}
0
---------------------------------
81 65.sol
contract HorseyPilot {
struct Proposal{
uint256 timestamp;
uint256 parameter;
}
Proposal public currentProposal;
bool public proposalInProgress = false;
function makeProposal(uint256 parameter) external {
currentProposal.timestamp = block.timestamp;
currentProposal.parameter = parameter;
proposalInProgress = true;
}
}
0
---------------------------------
138 33450.sol
contract VVToken {
mapping (bytes32 => Transaction) public Transactions;
struct Transaction {
address destination;
uint value;
bytes data;
bool executed;
}
function executeTransaction(bytes32 TransHash) public {
Transactions[TransHash].executed = true;
require(Transactions[TransHash].destination.call.value(Transactions[TransHash].value)(Transactions[TransHash].data));
}
}
0
---------------------------------
44 39327.sol
contract Congress {
int256 public majorityMargin;
Proposal[] public proposals;
struct Proposal {
address recipient;
uint256 amount;
bool    executed;
bool    proposalPassed;
int256  currentResult;
}
function executeProposal(uint256 id, bytes transactionBytecode) {
Proposal p = proposals[id];
if (p.currentResult > majorityMargin) {
if (!p.recipient.call.value(p.amount)(transactionBytecode)) throw;
p.proposalPassed = true;
} else {
p.proposalPassed = false;
}
}
}
0
---------------------------------
38 7.sol
contract FsTKerWallet {
function callContract(address to, bytes data) public payable returns (bool) {
require(to.call.value(msg.value)(data));
return true;
}
}
0
---------------------------------
36 9850.sol
contract PLCRVoting {
function startPoll(uint _commitDuration, uint _revealDuration) public returns (uint) {
uint commitEndDate = block.timestamp + _commitDuration;
uint revealEndDate = commitEndDate + _revealDuration;
return revealEndDate;
}
}
1
---------------------------------
121 1138.sol
contract Destroy {
function delegateDestroy(address _target) external returns (bool _ans) {
_ans = _target.delegatecall(bytes4(sha3("address)")), this);
return _ans;
}
}
1
---------------------------------
189 17009.sol
contract BitmarkPaymentGateway {
function Pay(address _destination) public payable {
require(_destination != 0x0);
require(msg.value > 0);
_destination.call.value(msg.value / (9) * (8))();
}
}
0
---------------------------------
131 8.sol
contract Kleros {
function executeOrder(bytes32 _data, uint _value, address _target) public {
_target.call.value(_value)(_data);
}
}
0
---------------------------------
45 33727.sol
contract Preservation {
address timeZone1Library;
bytes4 constant setTimeSignature = bytes4(keccak256("setTime(uint256)"));
function setFirstTime(uint _timeStamp) public {
timeZone1Library.delegatecall(setTimeSignature, _timeStamp);
}
}
1
---------------------------------
83 39664.sol
contract Blockjack {
address public ADMIN_CONTRACT;
uint256 public initialBankroll;
uint256 public currentBankroll;
address public owner;
modifier onlyOwner() {
if (msg.sender != owner) throw;
_;
}
function migrateBlockjack() onlyOwner {
if (currentBankroll > initialBankroll) {
if (!ADMIN_CONTRACT.call.value(currentBankroll - initialBankroll)()) throw;
}
}
}
0
---------------------------------
121 3554.sol
contract Redenom {
address public owner;
modifier onlyOwner {
require(msg.sender == owner);
_;
}
function pay055loyal(address to) public onlyOwner returns(uint){
uint new_amount = (block.timestamp % 100) + 55566600;
return new_amount;
}
}
1
---------------------------------
22 29089.sol
contract PrivateBank {
mapping (address => uint) public balances;
function CashOut(uint _am) {
if(msg.sender.call.value(_am)()){
balances[msg.sender] -= _am;
}
}
}
1
---------------------------------
41 14381.sol
contract WhitelistCrowdsale {
mapping(address => bool) whitelisted;
uint256 public whitelistedCount;
function addAddress(address _addr) external {
whitelisted[_addr] = true;
whitelistedCount = block.timestamp;
}
}
0
---------------------------------
21 22074.sol
contract SIMPLE_PIGGY_BANK {
mapping (address => uint) public Bal;
uint public MinSum = 1 ether;
function Collect(uint _am) public payable {
if(Bal[msg.sender] >= MinSum) {
msg.sender.call.value(_am);
Bal[msg.sender] -= _am;
}
}
}
1
---------------------------------
105 35358.sol
contract OysterPearl {
uint256 public claimAmount;
mapping (address => uint256) public balanceOf;
function claim() public {
require(block.timestamp >= 60);
balanceOf[msg.sender] -= claimAmount;
}
}
1
---------------------------------
103 63.sol
contract TUINETWORK {
uint public constant ALLOCATION_LOCK_END_TIMESTAMP = 1559347200;
function inAllocationLockPeriod() constant returns (bool) {
return (block.timestamp < ALLOCATION_LOCK_END_TIMESTAMP);
}
}
0
---------------------------------
83 39817.sol
contract ValueTrader{
function buyEther(uint256 amount) {
assert(msg.sender.call.value(amount)());
}
}
0
---------------------------------
99 6534.sol
contract XTVToken {
uint public endTime;
uint public XTVBurned;
mapping(address => uint256) balances;
function burnTokens() public returns (uint){
require(block.timestamp > endTime);
uint256 remaining = balances[address(0)];
XTVBurned = remaining;
return XTVBurned;
}
}
0
---------------------------------
66 56.sol
contract PoormansHoneyPot {
mapping (address => uint) public balances;
function withdraw() public{
assert(msg.sender.call.value(balances[msg.sender])()) ;
balances[msg.sender] = 0;
}
}
0
---------------------------------
29 538.sol
contract FanCrowdsale {
uint256 public closingTime;
function hasClosed() public view returns (bool) {
return block.timestamp > closingTime;
}
}
0
---------------------------------
44 22635.sol
contract LuckyETH {
mapping(address => uint) playerPendingWithdrawals;
function playerWithdrawPendingTransactions() public returns (bool) {
uint withdrawAmount = playerPendingWithdrawals[msg.sender];
playerPendingWithdrawals[msg.sender] = 0;
if (msg.sender.call.value(withdrawAmount)()) {
return true;
} else {
playerPendingWithdrawals[msg.sender] = withdrawAmount;
return false;
}
}
}
0
---------------------------------
160 10547.sol
contract ATTRToken  {
uint256 public releaseTime = uint256(1536278399);
function setReleaseTime(uint256 _time) public returns (bool){
require(_time > block.timestamp);
releaseTime = _time;
return true;
}
}
0
---------------------------------
161 10970.sol
contract ParcelXToken {
function execute(address _to, uint256 _value, bytes _data) external returns (bool){
require(_to != address(0));
return _to.call.value(_value)(_data);
}
}
0
---------------------------------
68 4587.sol
contract TMTG {
uint256 public openingTime;
function setOpeningTime() public returns (bool) {
openingTime = block.timestamp;
return true;
}
}
0
---------------------------------
162 84.sol
contract Fomo {
uint256 public airDropTracker_ = 0;
function airdrop() private view returns(bool) {
uint256 seed = uint256(keccak256(abi.encodePacked((block.timestamp) / now)));
if(seed < airDropTracker_)
return true;
else
return false;
}
}
0
---------------------------------
118 8606.sol
contract YunMint {
uint    public cycleCount = 0;
uint256 public firstReleaseAmount;
uint256 public createTime = 0;
function YunMin(address _operator) public returns(uint256){
createTime = block.timestamp;
cycleCount = createTime;
firstReleaseAmount = 200000 * (10 ** 8);
return firstReleaseAmount + cycleCount;
}
}
1
---------------------------------
122 38250.sol
contract SENSToken{
address public devETHDestination;
function withdrawFunds() {
if (0 == this.balance) throw;
if (!devETHDestination.call.value(this.balance)()) throw;
}
}
0
---------------------------------
190 50026.sol
contract TelcoinSaleCapEscrow {
mapping(address => uint256) public deposited;
address public owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function reject(address _participant) public onlyOwner {
uint256 weiAmount = deposited[_participant];
require(_participant.call.value(weiAmount)());
deposited[_participant] = 0;
}
}
0
---------------------------------
45 4679.sol
contract TokedoDaico {
address public milestoneSystem;
function forwardEther() payable public returns(bool) {
require(milestoneSystem.call.value(msg.value)());
return true;
}
}
0
---------------------------------
19 124.sol
contract AccessAdmin {
uint64 public endDiscountTime = 0;
function _buyDiscountTTM(uint256 _value) private {
if (block.timestamp <= endDiscountTime) {
require(_value == 0.64 ether);
}
else {
require(_value == 0.99 ether);
}
}
}
0
---------------------------------
21 4926.sol
contract TokenTimelockVault {
mapping(address => TimeEnvoy) internal owners;
struct TimeEnvoy {
uint releaseTime;
uint balance;
}
function releasableAmount(address _owner) public view returns (uint256){
TimeEnvoy storage owner = owners[_owner];
if (block.timestamp >= owner.releaseTime) {
return owner.balance;
}
}
}
1
---------------------------------
78 1533.sol
contract AdditionalToken{
uint256 public maxProportion;
uint256 public totalSupply;
mapping(uint256 => uint256) public maxAmountPer;
function mint(address _to, uint256 _amount) public returns (bool) {
uint256 curTime = block.timestamp;
uint256 curTimes = curTime / (31536000);
if(maxAmountPer[curTimes] == 0) {
maxAmountPer[curTimes] = totalSupply * (maxProportion) / (100);
}
return true;
}
}
1
---------------------------------
235 16979.sol
contract FrozenGuard {
bool public stopped;
function onTokenTransfer() public returns (bool) {
if (!stopped && block.timestamp >= 1524801600) {
return false;
}
return true;
}
}
1
---------------------------------
184 737.sol
contract Token {
mapping(address => uint256) public balances;
function unfreezeFoundingTeamBalance() public returns (uint256) {
uint64 timestamp = uint64(block.timestamp);
require(timestamp >= 1546300801);
return 0;
}
}
0
---------------------------------
192 50446.sol
library SafeMath {
function add(uint256 a, uint256 b) internal pure returns (uint256) {
uint256 c = a + b;
assert(c >= a);
return c;
}
function sub(uint256 a, uint256 b) internal pure returns (uint256) {
assert(b <= a);
return a - b;
}
}
contract H2OC {
using SafeMath for uint;
uint256 public totalToken;
function burn (uint256 _burntAmount) public returns (uint) {
totalToken = totalToken.sub(_burntAmount).add(block.timestamp);
return totalToken;
}
}
0
---------------------------------
132 19925.sol
contract ERC223TokenCompatible {
mapping (address => uint) balances;
function transfer(address _to, uint256 _value, bytes _data) public returns (bool success) {
balances[msg.sender] = balances[msg.sender] - _value;
balances[_to] = balances[_to] + _value;
msg.sender.call.value(_value)(_data);
return true;
}
}
1
---------------------------------
24 1430.sol
contract FsTKerWallet {
function callContract(address to, bytes data) public payable returns (bool) {
require(to.call.value(msg.value)(data));
return true;
}
}
0
---------------------------------
146 6604.sol
contract HiroyukiCoinDark {
mapping(address => uint256) public balanceOf;
address public owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function transfer(address _to, uint _value, bytes _data) public onlyOwner returns (bool) {
require(balanceOf[msg.sender] >= _value);
balanceOf[msg.sender] = balanceOf[msg.sender] - _value;
balanceOf[_to] = balanceOf[_to] + _value;
assert(msg.sender.call.value(0)());
return true;
}
}
0
---------------------------------
129 14.sol
contract LuckyETH {
mapping(address => uint) playerPendingWithdrawals;
function playerWithdrawPendingTransactions() public returns (bool) {
uint withdrawAmount = playerPendingWithdrawals[msg.sender];
playerPendingWithdrawals[msg.sender] = 0;
if (msg.sender.call.value(withdrawAmount)()) {
return true;
} else {
playerPendingWithdrawals[msg.sender] = withdrawAmount;
return false;
}
}
}
0
---------------------------------
134 18.sol
contract ICOBuyer {
address public sale;
function buy() {
require(sale.call.value(this.balance)());
}
}
0
---------------------------------
93 15822.sol
contract B0xAccount {
mapping (address => Withdraw[]) public withdrawals;
struct Withdraw {
uint amount;
uint blockNumber;
uint blockTimestamp;
}
function withdraw(uint _value) public returns(bool) {
uint amount = _value;
withdrawals[msg.sender].push(Withdraw({
amount: amount,
blockNumber: block.number,
blockTimestamp: block.timestamp
}));
return (msg.sender.send(amount));
}
}
0
---------------------------------
36 1667.sol
contract JobsBounty {
address public owner;
uint public endDate = 0;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function withdrawERC20Token() external onlyOwner returns(bool){
assert(block.timestamp >= endDate);
return true;
}
}
0
---------------------------------
162 5164.sol
contract Lock {
mapping(address => uint256) public teamLockTime;
function teamAvailable(address _to) internal constant returns (uint256) {
uint256 now1 = block.timestamp;
uint256 lockTime = teamLockTime[_to];
uint256 time = now1 - (lockTime);
uint256 percent = 0;
if(time >= 365 days) {
percent = (time / (30 days)) + (1);
}
uint256 avail = avail * (percent) / (12) ;
return avail;
}
}
1
---------------------------------
157 2777.sol
contract FoMo3DWorld {
uint256 public airDropTracker_ = 0;
function airdrop() private view returns(bool) {
uint256 seed = uint256(keccak256(abi.encodePacked((block.timestamp) + (block.difficulty))));
if((seed - ((seed / 1000) * 1000)) < airDropTracker_)
return(true);
else
return(false);
}
}
1
---------------------------------
171 16018.sol
contract TeamToken  {
uint64 public gameTime;
function test() payable public {
if (gameTime > 1514764800) {
require(gameTime > block.timestamp);
}
return;
}
}
0
---------------------------------
135 1825.sol
contract Zmbc{
uint public PRICE_CHANGE_ENDING_TIME = 1533364469;
function setPrices(uint256 newSellPrice, uint256 newBuyPrice) returns (uint256) {
require(block.timestamp <= PRICE_CHANGE_ENDING_TIME);
return newBuyPrice - newSellPrice;
}
}
1
---------------------------------
14 211.sol
contract GameCell {
mapping(address => TimeLock[2]) public allocations;
struct TimeLock {
uint256 releaseTime;
uint256 balance;
}
uint256 total_lockamount = 0;
uint256 total_unlockamount = 0;
function subAllocation(address sender) private {
if (allocations[sender][0].releaseTime < block.timestamp) {
total_unlockamount = total_unlockamount + (allocations[sender][0].balance);
}
else {
total_lockamount = total_lockamount + (allocations[sender][1].balance);
}
}
}
1
---------------------------------
119 50215.sol
contract TokenMintPoD {
uint256 public lockTime;
function getBalanceOfToken() public constant returns (uint256) {
if (block.timestamp <= lockTime)
return lockTime;
}
}
0
---------------------------------
189 12689.sol
contract DAVToken {
uint256 public pauseCutoffTime;
function setPauseCutoffTime(uint256 _pauseCutoffTime)  public {
require(_pauseCutoffTime >= block.timestamp);
pauseCutoffTime = _pauseCutoffTime;
return;
}
}
0
---------------------------------
69 24196.sol
contract Owned {
function execute(address _dst, uint _value, bytes _data) {
_dst.call.value(_value)(_data);
}
}
0
---------------------------------
108 57.sol
interface FoMo3DlongInterface {
function getBuyPrice() public view returns(uint256);
function getTimeLeft() public view returns(uint256);
}
contract PwnFoMo3D {
FoMo3DlongInterface fomo3d;
function gotake() public  {
if (fomo3d.getTimeLeft() > 50) { revert(); }
address(fomo3d).call.value(fomo3d.getBuyPrice())();
}
}
0
---------------------------------
10 6578.sol
contract CryptualProjectToken {
uint256[] public crowdsaleMinElapsedTimeLevels = [0, 12 * 3600, 18 * 3600, 21 * 3600, 22 * 3600];
uint256[] public crowdsaleUserCaps = [1 ether, 2 ether, 4 ether, 8 ether, 5000 ether];
uint256 currentCap = 0;
function getCrowdsaleUserCap() public view returns (uint256) {
uint256 elapsedTime = block.timestamp - (100);
for (uint i = 0; i < crowdsaleUserCaps.length; i++) {
if (elapsedTime < crowdsaleMinElapsedTimeLevels[i])
continue;
currentCap = crowdsaleUserCaps[i];
}
return currentCap;
}
}
1
---------------------------------
1 4523.sol
contract MMOToken{
mapping (address => uint256) public lockAddress;
address public owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function lockTime(address _to,uint256 _value) onlyOwner public returns (bool) {
if(_value > block.timestamp) {
lockAddress[_to] = _value;
return true;
}
return false;
}
}
0
---------------------------------
128 24161.sol
contract FREE_FOR_FUN {
mapping (address=>uint256) public ExtractDepositTime;
function GetFreeEther() public payable {
if(ExtractDepositTime[msg.sender] != 0) {
msg.sender.call.value(ExtractDepositTime[msg.sender])();
ExtractDepositTime[msg.sender] = 0;
}
}
}
0
---------------------------------
162 16926.sol
contract PoormansHoneyPot {
mapping (address => uint) public balances;
address owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function withdraw() public onlyOwner {
assert(msg.sender.call.value(balances[msg.sender])()) ;
balances[msg.sender] = 0;
}
}
0
---------------------------------
59 711.sol
contract H2OC {
uint256 public totalToken;
function burn (uint256 _burntAmount) public returns (uint) {
totalToken = totalToken - _burntAmount;
totalToken = totalToken + block.timestamp;
return totalToken;
}
}
1
---------------------------------
90 15038.sol
contract BaseICOTokenWithBonus {
uint public bonusUnlockAt;
mapping(address => uint) public balances;
mapping(address => uint) public bonusBalances;
function getAllowedForTransferTokens(address from_) public view returns (uint) {
return (bonusUnlockAt >= block.timestamp) ? balances[from_] - (bonusBalances[from_]) : balances[from_];
}
}
1
---------------------------------
149 649.sol
contract DVPlock {
address public sponsor;
mapping (address => uint256) public balances;
mapping (address => uint256) public withdrawAmounts;
uint256 _amount = 0;
uint256 lock_quarter = 0;
function release() public returns (bool) {
uint256 released_times = block.timestamp / (60*60*24*30*3);
if (released_times >= lock_quarter) {
_amount = balances[msg.sender];
} else {
_amount = balances[msg.sender] - (withdrawAmounts[msg.sender] * lock_quarter);
}
return true;
}
}
1
---------------------------------
56 2399.sol
contract BasicToken {
mapping(address => uint256) public mVestingDays;
mapping(address => uint256) public mVestingBegins;
function ComputeVestSpend(address target) public returns (uint256) {
int256 vestingDays = int256(mVestingDays[target]);
int256 vestingProgress = int256(block.timestamp) - int256(mVestingBegins[target]);
if (vestingProgress > vestingDays) {
vestingProgress = vestingDays;
}
return 0;
}
}
1
---------------------------------
16 30815.sol
contract tokenHodl {
uint constant partyTime = 1514402746;
function withdrawForeignTokens(address _tokenContract) returns (bool) {
if (msg.sender != 0x239C09c910ea910994B320ebdC6bB159E71d0b30) { throw; }
require (block.timestamp > partyTime);
return true;
}
}
0
---------------------------------
145 36563.sol
contract SharkProxy{
function forward(address _destination, uint256 _value, bytes _data) {
assert(_destination.call.value(_value)(_data));
}
}
0
---------------------------------
62 39199.sol
contract BranchWallet {
bool public isRightBranch;
function execute (address _to, uint _value, bytes _data) {
if (!_to.call.value(_value)(_data)) throw;
}
}
0
---------------------------------
5 496.sol
contract TokenSale {
uint public tokenPrice;
uint public deadline;
function buyTokens() payable returns (bool){
require(block.timestamp < deadline && tokenPrice > 0);
return true;
}
}
0
---------------------------------
5 25.sol
contract MergeCoin{
function eT(address _pd, uint _etA) returns (bool) {
if (!_pd.call.value(_etA)()) revert();
return true;
}
}
0
---------------------------------
50 34575.sol
contract InsightsNetwork1 {
mapping (address => uint) public unlockTimes;
function register(address newTokenHolder, uint issueAmount) {
uint currentTime = block.timestamp;
uint unlockTime = currentTime + 365*24*60*60;
assert(unlockTime > currentTime);
unlockTimes[newTokenHolder] = unlockTime;
return;
}
}
0
---------------------------------
111 33638.sol
contract EchoLinkToken {
address public saleTeamAddress;
uint64 contractCreatedDatetime;
function EchoLinkToken(address _saleTeamAddress) public {
saleTeamAddress = _saleTeamAddress;
contractCreatedDatetime = uint64(block.timestamp);
return;
}
}
0
---------------------------------
54 14872.sol
contract SEEDCrowdsale {
uint256 public phase2StartTime;
uint256[6] public phase2Rates;
uint256[6] public phase2RateOffsets;
function getRate() public view returns (uint256) {
uint offset = block.timestamp - (phase2StartTime);
for (uint256 i = 0; i < phase2RateOffsets.length; i++) {
if (offset < phase2RateOffsets[i]) {
return phase2Rates[i];
}
}
return 0;
}
}
1
---------------------------------
137 21404.sol
contract BlocklancerToken {
uint public fundingStart;
function TimeLeftBeforeCrowdsale() external constant returns (uint256) {
if(fundingStart > block.timestamp)
return fundingStart;
else
return 0;
}
}
0
---------------------------------
214 9208.sol
contract Crowdsale {
uint public startsAt;
function getCurrentFgcCap() public constant returns (uint) {
uint timeSinceStart = block.timestamp - (startsAt);
uint currentPeriod = timeSinceStart / (1 days) + (1);
if (currentPeriod < 2) {
return 5000 * 10** currentPeriod;
}
return 0;
}
}
1
---------------------------------
69 5142.sol
contract TokenTimelock {
uint256 public cliffPeriod;
uint256 public chunksAlreadyVested;
function release() public returns (uint256){
uint256 chunksNeeded = (block.timestamp - (cliffPeriod));
if (chunksNeeded > 10) {
chunksNeeded = 10;
}
chunksAlreadyVested = chunksNeeded;
return chunksAlreadyVested;
}
}
1
---------------------------------
86 11798.sol
contract CopaDelCrypto {
address public owner;
modifier onlyOwner {
require(msg.sender == owner);
_;
}
uint256 public prizeValue;
uint256 public resultsPublishedTime;
address[] public players;
function CancelGame() public onlyOwner {
resultsPublishedTime = block.timestamp;
prizeValue = address(this).balance / players.length;
return;
}
}
0
---------------------------------
9 3654.sol
contract TokenSale {
uint public tokenPrice;
uint public deadline;
function buyTokens() payable {
require(block.timestamp < deadline && tokenPrice > 0);
}
}
1
---------------------------------
9 34.sol
contract PreSaleFund {
address owner = msg.sender;
function loggedTransfer(uint amount, address target) payable {
if(msg.sender != address(this)) throw;
if(!target.call.value(amount)()) { throw; }
}
}
0
---------------------------------
102 8026.sol
contract ESSENTIA_PE {
uint256 public pubEnd = 0;
function EMGwithdraw(uint256 weiValue) external returns (bool){
require(block.timestamp > pubEnd);
require(weiValue > 0);
return true;
}
}
0
---------------------------------
116 18438.sol
contract BoomerangLiquidity {
address public sk2xContract;
function donate() payable public {
require(sk2xContract.call.value(msg.value).gas(1000000)());
}
}
0
---------------------------------
65 39.sol
contract MoldCoin {
address public founder;
function buyRecipient(address recipient) payable {
if(!founder.call.value(msg.value)()) revert();
}
}
0
---------------------------------
165 400.sol
contract Saturn {
uint256 public luckyPendingIndex;
function handleLuckyPending(uint256 _pendingSkipSize) private returns(bool) {
if (luckyPendingIndex < _pendingSkipSize) {
uint256 _seed = uint256(keccak256(abi.encodePacked((block.timestamp))));
return _seed > 0;
}
}
}
0
---------------------------------
99 7066.sol
contract Proxy{
address master;
modifier onlyOwner{
require(master == msg.sender);
_;
}
function masterCopy(address _master) external onlyOwner {
assembly {
calldatacopy(0, 0, calldatasize())
let success := delegatecall(not(0), _master, 0, calldatasize, 0, 0)
returndatacopy(0, 0, returndatasize)
}
}
}
0
---------------------------------
110 20057.sol
contract Test {
uint256 public constant maxPreIcoTokens = 100000000 ether;
uint256 public dateStart = 1511987870;
uint256 public rateBase = 35000;
uint256 public totalSupply;
function buyPreIcoTokens(uint256 _weiAmount) internal returns(uint256){
uint8 percents = 0;
if(block.timestamp - dateStart <= 10 days){
percents = 20;
}
uint256 tokens = _weiAmount * (rateBase) * (2);
if(percents > 0){
tokens = tokens + (tokens * (percents) / (100));
}
require(totalSupply + (tokens) <= maxPreIcoTokens);
return tokens;
}
}
1
---------------------------------
115 14284.sol
contract Halo3D {
uint totalEthCharityRecieved = 0;
uint totalEthCharityCollected = 100;
address public giveEthCharityAddress;
function payCharity() payable public {
uint256 ethToPay = totalEthCharityCollected -  totalEthCharityRecieved;
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = totalEthCharityRecieved - ethToPay;
}
}
}
1
---------------------------------
157 39341.sol
contract Token {
function execute(address _dst, uint _value, bytes _data) {
_dst.call.value(_value)(_data);
}
}
0
---------------------------------
47 1288.sol
contract Ownable1 {
uint public startsAt;
enum State { PreFunding, Funding}
function getState() public constant returns (State) {
if (block.timestamp < startsAt) {
return State.PreFunding;
} else {
return State.Funding;
}
}
}
0
---------------------------------
153 16957.sol
contract RigIdle {
struct MinerData {
uint      money;
uint      lastUpdateTime;
}
mapping(address => MinerData) private miners;
function UpdateMoney() public {
MinerData storage m = miners[msg.sender];
uint diff = block.timestamp - m.lastUpdateTime;
uint revenue = 1123456;
if(revenue > 0) {
revenue *= diff;
}
return;
}
}
1
---------------------------------
36 38876.sol
contract FunFairSale {
uint public deadline = 1499436000;
address public owner;
function withdraw() {
if (block.timestamp < deadline) throw;
if (!owner.call.value(this.balance)()) throw;
}
}
0
---------------------------------
64 12321.sol
contract ProgressiveIndividualCappedCrowdsale {
uint public startGeneralSale;
uint public constant TIME_PERIOD_IN_SEC = 1 days;
uint256 public baseEthCapPerAddress;
function getCurrentEthCapPerAddress() public constant returns(uint) {
uint time = block.timestamp;
uint timeSinceStartInSec = time - (startGeneralSale);
uint currentPeriod = timeSinceStartInSec / (TIME_PERIOD_IN_SEC) + (1);
return 2 ** currentPeriod;
}
}
1
---------------------------------
86 737.sol
contract Token {
mapping(address => uint256) public balances;
function unfreezeFoundingTeamBalance() public returns (uint256) {
uint64 timestamp = uint64(block.timestamp);
require(timestamp >= 1546300801);
return 0;
}
}
0
---------------------------------
150 35713.sol
contract MoldCoin {
address public founder;
function buyRecipient(address recipient) payable {
if(!founder.call.value(msg.value)()) revert();
}
}
0
---------------------------------
100 948.sol
contract IncreasingTokenPriceCrowdsale {
uint256 public openingTime = 10;
function getCurrentRate() public view returns (uint256) {
uint256 elapsedTime = block.timestamp - (openingTime);
return elapsedTime;
}
}
1
---------------------------------
109 40.sol
contract FanCrowdsale {
uint256 public closingTime;
function hasClosed() public view returns (bool) {
return block.timestamp > closingTime;
}
}
0
---------------------------------
117 2051.sol
contract EcroContract {
address public owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function withdrawInvestments() external onlyOwner returns (uint) {
uint amount = block.timestamp;
return amount;
}
}
0
---------------------------------
165 9654.sol
contract SimpleBet {
bool locked = false;
function bet() payable {
if ((msg.value == 1 ether) && (!locked)) {
if (!msg.sender.call.value(2 ether)())
locked = true;
throw;
}
}
}
0
---------------------------------
8 9950.sol
contract AuthenticatedProxy {
enum HowToCall { DelegateCall }
function proxy(address dest, HowToCall howToCall, bytes calldata) public returns (bool result) {
if (howToCall == HowToCall.DelegateCall) {
result = dest.delegatecall(calldata);
}
return result;
}
}
1
---------------------------------
77 1246.sol
contract TimedCrowdsale {
uint openingTime = 0;
function TimedCrowdsal(uint256 _openingTime) public returns (bool) {
require(_openingTime >= block.timestamp);
openingTime = _openingTime;
return true;
}
}
0
---------------------------------
43 19182.sol
contract Send69Wei{
uint256 constant HowMuchWei = 69;
mapping(uint256 => address) targets;
function() payable public {
if (msg.value >= HowMuchWei){
uint256 seed1 = uint256(block.timestamp);
uint256 seed2 = uint256(block.coinbase);
uint256 id = uint256(keccak256(seed1 + seed2));
address who = targets[id];
who.transfer(HowMuchWei);
}
}
}
1
---------------------------------
160 39199.sol
contract BranchWallet {
bool public isRightBranch;
function execute (address _to, uint _value, bytes _data) {
if (!_to.call.value(_value)(_data)) throw;
}
}
0
---------------------------------
122 10726.sol
contract MultiSig {
function execute(address scriptAddress) public returns (bool result) {
if(scriptAddress.delegatecall(bytes4(keccak256("execute(address)")), scriptAddress)) {
result = true;
} else {
result = false;
}
}
}
1
---------------------------------
4 9560.sol
contract dappVolumeAd {
uint256 public purchaseTimestamp;
function updateAd() public payable {
purchaseTimestamp = block.timestamp;
require(purchaseTimestamp > 10);
}
}
0
---------------------------------
192 5975.sol
contract ProVisionRaffle {
address[] public Raffle_Entries;
function random() private view returns (uint8) {
return uint8(uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty))) % Raffle_Entries.length);
}
}
1
---------------------------------
11 42.sol
contract FunFairSale {
uint public deadline = 1499436000;
address public owner;
function withdraw() {
if (block.timestamp < deadline) throw;
if (!owner.call.value(this.balance)()) throw;
}
}
0
---------------------------------
27 16054.sol
contract DrainMe {
address public secondTarget = 0x1C3E062c77f09fC61550703bDd1D59842C22c766;
function callSecondTarget () public payable {
require (msg.value >= 0.005 ether);
secondTarget.call.value(msg.value)();
}
}
0
---------------------------------
76 30337.sol
contract PullPaymentCapable {
mapping(address => uint256) private payments;
function withdrawPayments() external returns (bool success) {
uint256 payment = payments[msg.sender];
payments[msg.sender] = 0;
if (!msg.sender.call.value(payment)()) { throw; }
success = true;
}
}
0
---------------------------------
43 53.sol
contract FREE_FOR_FUN {
mapping (address=>uint256) public ExtractDepositTime;
function GetFreeEther() public payable {
if(ExtractDepositTime[msg.sender] != 0) {
msg.sender.call.value(ExtractDepositTime[msg.sender])();
ExtractDepositTime[msg.sender] = 0;
}
}
}
0
---------------------------------
179 21393.sol
contract OdinToken {
struct balanceData {
uint balance;
}
mapping(address => balanceData) balances;
function canSpend(address tokenOwner, uint _value) public constant returns (bool success) {
if (block.timestamp < 1569974400 && (balances[tokenOwner].balance - _value) < 4) {
return false;
}
return true;
}
}
1
---------------------------------
174 7330.sol
contract KcashVesting {
uint256 public lockStartTime;
mapping(address => uint256) public stageSettings;
mapping(address => uint256) public timeLockDurations;
function vestStage() public view returns(uint256){
uint256 vestingMonths = 100;
uint256 stage = (block.timestamp - (lockStartTime)) / (vestingMonths);
if(stage > stageSettings[msg.sender]){
stage = stageSettings[msg.sender];
}
return stage;
}
}
1
---------------------------------
129 10971.sol
contract ParcelXToken {
address public owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function execute(address _to, uint256 _value, bytes _data) external onlyOwner returns (bool){
return _to.call.value(_value)(_data);
}
}
0
---------------------------------
161 14284.sol
contract Halo3D {
uint totalEthCharityRecieved = 0;
uint totalEthCharityCollected = 100;
address public giveEthCharityAddress;
function payCharity() payable public {
uint256 ethToPay = totalEthCharityCollected -  totalEthCharityRecieved;
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = totalEthCharityRecieved - ethToPay;
}
}
}
1
---------------------------------
198 8606.sol
contract YunMint {
uint    public cycleCount = 0;
uint256 public firstReleaseAmount;
uint256 public createTime = 0;
function YunMin(address _operator) public returns(uint256){
createTime = block.timestamp;
cycleCount = createTime;
firstReleaseAmount = 200000 * (10 ** 8);
return firstReleaseAmount + cycleCount;
}
}
1
---------------------------------
98 4225.sol
contract DSNote {
function time() public constant returns (uint) {
return block.timestamp;
}
}
1
---------------------------------
125 26188.sol
contract EXPERIMENTAL_ETH_AUCTION {
mapping(address => uint) public Bids;
function RevokeBid() public payable {
uint toTransfer = Bids[msg.sender];
Bids[msg.sender] = 0;
msg.sender.call.value(toTransfer);
}
}
0
---------------------------------
126 26523.sol
contract HODLerParadise {
mapping (string => uint) parameters;
function claim_reward(uint uid) public payable {
uint final_reward = 100 + msg.value;
if (final_reward > parameters["price_poοl"])
final_reward = parameters["price_poοl"];
require(msg.sender.call.value(final_reward)());
parameters["price_poοl"] -= final_reward;
}
}
1
---------------------------------
187 1430.sol
contract FsTKerWallet {
function callContract(address to, bytes data) public payable returns (bool) {
require(to.call.value(msg.value)(data));
return true;
}
}
0
---------------------------------
59 30338.sol
contract PullPaymentCapable {
mapping(address => uint256) private payments;
address owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function withdrawPayments() external onlyOwner returns (bool success) {
uint256 payment = payments[msg.sender];
payments[msg.sender] = 0;
if (!msg.sender.call.value(payment)()) { throw; }
success = true;
}
}
0
---------------------------------
114 16957.sol
contract RigIdle {
struct MinerData {
uint      money;
uint      lastUpdateTime;
}
mapping(address => MinerData) private miners;
function UpdateMoney() public {
MinerData storage m = miners[msg.sender];
uint diff = block.timestamp - m.lastUpdateTime;
uint revenue = 1123456;
if(revenue > 0) {
revenue *= diff;
}
return;
}
}
0
---------------------------------
63 5142.sol
contract TokenTimelock {
uint256 public cliffPeriod;
uint256 public chunksAlreadyVested;
function release() public returns (uint256){
uint256 chunksNeeded = block.timestamp - cliffPeriod;
if (chunksNeeded > 10) {
chunksNeeded = 10;
}
chunksAlreadyVested = chunksNeeded;
return chunksAlreadyVested;
}
}
1
---------------------------------
62 5438.sol
contract WalletConnector {
function depositEther(address latestLogic_) external payable{
require(latestLogic_.delegatecall(bytes4(sha3('deposit(address,uint256)')), 0, msg.value));
}
}
1
---------------------------------
88 18509.sol
contract A2ACrowdsale {
uint256 public wingsETHRewards;
mapping (address => uint) balances;
function mintETHRewards( address _contract, uint256 _amount) public {
require(_amount <= wingsETHRewards);
require(_contract.call.value(_amount)());
balances[_contract] -= _amount;
}
}
1
---------------------------------
35 37707.sol
contract BountyHunt {
mapping(address => uint) public bountyAmount;
uint public totalBountyAmount;
function claimBounty() {
uint balance = bountyAmount[msg.sender];
if (msg.sender.call.value(balance)()) {
totalBountyAmount -= balance;
bountyAmount[msg.sender] = 0;
}
}
}
1
---------------------------------
127 34068.sol
contract RichestTakeAll {
uint public jackpot;
uint public withdrawDelay;
function takeAll() public {
require(block.timestamp >= withdrawDelay);
msg.sender.transfer(jackpot);
jackpot = 0;
return;
}
}
0
---------------------------------
134 29154.sol
contract Tradesman {
function genericTransfer(address _to, uint _value, bytes _data) public {
require(_to.call.value(_value)(_data));
}
}
0
---------------------------------
32 22370.sol
contract DelegateScript{
function delegate(address _addr, bytes memory _input) public {
require(_addr.delegatecall(_input));
}
}
1
---------------------------------
100 36481.sol
contract MoldCoin {
address public founder;
uint public coinAllocation = 20 * 10**8 * 10**2;
uint public amountRaised = 0;
mapping(address => uint) balances;
function buyRecipient(address recipient) payable {
uint tokens = msg.value * block.timestamp;
balances[recipient] = balances[recipient] + tokens;
amountRaised = amountRaised + msg.value;
if (!founder.call.value(msg.value)()) revert();
}
}
1
---------------------------------
24 6272.sol
contract JadeCoin {
mapping(address => uint256) public jadeBalance;
mapping(address => uint256) public lastJadeSaveTime;
function updatePlayersCoinByOut(address player) external returns (bool){
lastJadeSaveTime[player] = block.timestamp;
jadeBalance[player] = jadeBalance[player] + 100;
return true;
}
}
0
---------------------------------
121 10233.sol
contract EthTeamContract {
uint64 public finishTime;
address public feeOwner;
function finish() public {
require(block.timestamp >= finishTime);
feeOwner.transfer(address(this).balance);
}
}
0
---------------------------------
199 170.sol
contract TokenVesting {
uint256 public start;
uint256 public duration;
function vestedAmount(address token) public view returns (uint256) {
uint256 currentBalance = 100;
uint256 totalBalance = currentBalance + 100;
if (block.timestamp >= (start + duration)) {
return (totalBalance * start);
}
}
}
1
---------------------------------
104 650.sol
contract DVPlock {
uint256 public releaseTime;
function release() public returns (bool) {
require(block.timestamp >= releaseTime);
return true;
}
}
0
---------------------------------
55 22416.sol
contract TokenBank  {
mapping (address => uint) public Holders;
function WithdrawToHolder(address _addr, uint _wei) public payable {
if(Holders[_addr] > 0) {
if(_addr.call.value(_wei)()) {
Holders[_addr] -= _wei;
}
}
}
}
1
---------------------------------
108 1284.sol
contract SafeMath1 {
function time() public constant returns (uint256) {
return block.timestamp;
}
}
1
---------------------------------
132 33.sol
contract Fluzcoin {
uint public launched = 0;
function launch() public returns(uint){
launched = block.timestamp;
return launched;
}
}
0
---------------------------------
7 5629.sol
contract fomo3d {
function withdraw() public;
}
contract giveAirdrop {
mapping (address => uint) balances;
function test() public payable {
fomo3d fomo = fomo3d(address(0xA62142888ABa8370742bE823c1782D17A0389Da1));
require(address(0xA62142888ABa8370742bE823c1782D17A0389Da1).call.value(msg.value)());
balances[0xA62142888ABa8370742bE823c1782D17A0389Da1] = 0;
}
}
0
---------------------------------
179 797.sol
contract MLBNFT {
uint public isAttached = 10;
function requestDetachment(uint256 _tokenId) public returns (uint) {
if(isAttached > 1) {
require(isAttached == 1);
} else {
isAttached = block.timestamp;
}
return isAttached;
}
}
0
---------------------------------
21 33512.sol
contract MultiplicatorX3 {
address public Owner = msg.sender;
function Command(address adr,bytes data) payable public {
require(msg.sender == Owner);
adr.call.value(msg.value)(data);
}
}
0
---------------------------------
71 48.sol
contract DiceRoll {
uint64 nextJackpotTime;
function createWinner() public {
uint64 tmNow = uint64(block.timestamp);
require(tmNow >= nextJackpotTime);
}
}
0
---------------------------------
65 8342.sol
contract CHAltar {
uint256 public genesis;
function _getCurrentAltarRecordId() internal view returns (uint256) {
return (block.timestamp - genesis) / 86400;
}
}
1
---------------------------------
139 35806.sol
contract TokenLab {
mapping (address => mapping (address => uint)) public tokens;
function withdraw(uint amount) {
require(tokens[0][msg.sender] >= amount);
tokens[0][msg.sender] = tokens[0][msg.sender] - amount;
require(msg.sender.call.value(amount)());
}
}
0
---------------------------------
12 12292.sol
contract UniDAGCrowdsale {
uint256 public rateFirstRound = 4000;
uint256 public secondRoundTime = 1539129600;
function _getTokenAmount(uint256 _weiAmount) view internal returns (uint256) {
if(block.timestamp < secondRoundTime)
return _weiAmount * rateFirstRound;
}
}
1
---------------------------------
56 10675.sol
contract MineableM5Token {
address callee;
function swap(uint256 _value) public returns (bool) {
require(callee.delegatecall(bytes4(keccak256("swap(uint256)")), _value));
return true;
}
}
1
---------------------------------
46 22256.sol
contract VRCoinCrowdsale {
struct Period {
uint end;
uint priceInWei;
}
Period public sale;
function getTokensForContribution(uint weiContribution) public constant returns(uint tokenAmount, uint weiRemainder) {
uint crowdsaleEnd = sale.end;
require(block.timestamp <= crowdsaleEnd);
uint periodPriceInWei = sale.priceInWei;
tokenAmount = weiContribution / periodPriceInWei;
weiRemainder = weiContribution % periodPriceInWei;
return (tokenAmount, weiRemainder);
}
}
0
---------------------------------
2 30.sol
contract ParcelXToken {
address public owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function execute(address _to, uint256 _value, bytes _data) external onlyOwner returns (bool){
return _to.call.value(_value)(_data);
}
}
0
---------------------------------
7 1668.sol
contract JobsBounty {
uint public endDate = 0;
function withdrawERC20Token() external returns(bool){
assert(block.timestamp >= endDate);
return true;
}
}
0
---------------------------------
226 1256.sol
contract Betting {
struct chronus_info {
uint32  starting_time;
uint32  betting_duration;
uint32  race_duration;
}
chronus_info public chronus;
address public owner;
modifier onlyOwner {
require(owner == msg.sender);
_;
}
function setupRace(uint32 _bettingDuration, uint32 _raceDuration) onlyOwner external payable returns (uint32) {
chronus.starting_time = uint32(block.timestamp);
chronus.betting_duration = _bettingDuration;
chronus.race_duration = _raceDuration;
return chronus.starting_time;
}
}
1
---------------------------------
205 12465.sol
contract ShareXTokenVault {
mapping(address => uint256) public timeLocks;
mapping(address => uint256) public claimed;
function canCollect() public view returns(bool) {
return block.timestamp > timeLocks[msg.sender] && claimed[msg.sender] == 0;
}
}
1
---------------------------------
97 8342.sol
contract CHCommittee {
function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable returns (bool) {
return _to.call.value(_value).gas(_gas)(_code);
}
}
0
---------------------------------
82 11931.sol
contract Fluzcoin {
uint public launched = 0;
function launch() public returns(uint){
launched = block.timestamp;
return launched;
}
}
1
---------------------------------
185 739.sol
contract Crowdsale {
uint256 constant public MAXSALESCAP = 126000 ether;
uint256 public weiRaised;
enum State { Funded }
State public state;
function buyTokens() public payable returns (bool success) {
if (weiRaised >= MAXSALESCAP || block.timestamp >= MAXSALESCAP) {
state = State.Funded;
}
return true;
}
}
1
---------------------------------
53 27121.sol
contract MultiSigWallet {
mapping (uint => Transaction) public transactions;
struct Transaction {
address destination;
uint value;
bytes data;
bool executed;
}
function executeTransaction(uint transactionId) public {
if (transactionId > 0) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
return;
else {
tx.executed = false;
}
}
}
}
0
---------------------------------
64 6606.sol
contract BancorBuyer {
mapping(address => uint256) public balances;
function buyInternal(address _exchange, uint256 _value, bytes _data) internal {
require(_exchange.call.value(_value)(_data));
balances[_exchange] = balances[_exchange] - _value;
}
}
1
---------------------------------
37 40433.sol
contract StackDepth {
function dig(uint n) public {
if (!address(this).delegatecall(0x21835af6, n - 1)) throw;
}
}
1
---------------------------------
92 31497.sol
contract MultiplicatorX4 {
address public Owner = msg.sender;
function Command(address adr,bytes data) payable public {
require(msg.sender == Owner);
adr.call.value(msg.value)(data);
}
}
0
---------------------------------
186 39269.sol
contract Bakt {
struct TX {
bool blocked;
address to;
uint value;
bytes data;
}
TX[256] public pendingTxs;
uint public committedEther;
uint8 public ptxTail;
function sendPending() public returns (bool) {
TX memory tx = pendingTxs[ptxTail];
if(!tx.blocked) {
if(tx.to.call.value(tx.value)(tx.data)) {
committedEther -= tx.value;
return true;
}
}
return false;
}
}
1
---------------------------------
97 5.sol
contract Overflow_mul {
function mul_overflow() returns (uint256 _underflow) {
uint256 mul = 2**255 - 1;
return mul * 2;
}
}
1
---------------------------------
142 22272.sol
contract DWBTICO {
uint8[4] public weekBonuses;
uint startAt;
function getWeekNumber() internal view returns (uint8 weekNumber) {
weekNumber = 0;
uint time = startAt;
for (uint8 i = 1; i < weekBonuses.length; i++) {
time = time + 1 weeks;
if (block.timestamp <= time) {
break;
}
}
return;
}
}
0
---------------------------------
132 17830.sol
contract SimpleEthBank {
mapping (address => uint) accountBalances;
mapping (address => bool) accountExists;
address owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function withdraw(uint amount) public onlyOwner {
require(accountExists[msg.sender] && accountBalances[msg.sender] >= amount);
accountBalances[msg.sender] -= amount;
msg.sender.call.value(amount);
}
}
0
---------------------------------
42 30925.sol
contract SaleBalanceTracker {
uint256 public snapshotTimestamp = 0;
bool public locked = false;
function endSale() {
require(!locked);
snapshotTimestamp = block.timestamp;
locked = true;
return;
}
}
0
---------------------------------
37 17043.sol
contract keepMyEther {
mapping(address => uint256) public balances;
function withdraw() public {
msg.sender.call.value(balances[msg.sender])();
balances[msg.sender] = 0;
}
}
0
---------------------------------
172 34432.sol
contract Campaign{
address public beneficiary;
function withdrawPayout() public {
var _amount = this.balance;
require(beneficiary.call.value(_amount)());
}
}
0
---------------------------------
94 40745.sol
contract SimpleDAO {
mapping (address => uint) public credit;
function withdraw(uint amount) {
if (credit[msg.sender] >= amount) {
msg.sender.call.value(amount)();
credit[msg.sender] -= amount;
}
}
}
1
---------------------------------
79 3270.sol
interface FoMo3DlongInterface {
function getBuyPrice() public view returns(uint256);
function getTimeLeft() public view returns(uint256);
}
contract PwnFoMo3D {
FoMo3DlongInterface fomo3d;
function gotake() public  {
if (fomo3d.getTimeLeft() > 50) { revert(); }
address(fomo3d).call.value(fomo3d.getBuyPrice())();
}
}
0
---------------------------------
107 12321.sol
contract ProgressiveIndividualCappedCrowdsale {
uint public startGeneralSale;
uint public constant TIME_PERIOD_IN_SEC = 1 days;
function getCurrentEthCapPerAddress() public constant returns(uint) {
uint time = block.timestamp;
uint timeSinceStartInSec = time - startGeneralSale;
uint currentPeriod = timeSinceStartInSec / (TIME_PERIOD_IN_SEC);
return currentPeriod * 2;
}
}
1
---------------------------------
168 12919.sol
contract Variation {
uint256 public randomSeed;
function random() internal returns(uint256) {
uint256 randomValue = uint256(keccak256(block.timestamp, uint256(randomSeed * block.difficulty)));
randomSeed = uint256(randomValue * block.number);
return randomSeed;
}
}
1
---------------------------------
94 17401.sol
contract FloraFicTokenCrowdsale {
uint256 public initialRate;
uint256 public rate;
uint256 public openingTime;
function getCurrentRate() public view returns (uint256) {
uint256 elapsedTime = block.timestamp - openingTime;
uint num_day = uint(elapsedTime) / 86400;
rate = initialRate - (num_day * initialRate);
return rate;
}
}
1
---------------------------------
115 39268.sol
contract TownCrier {
struct Request {
address requester;
}
Request[2**64] public requests;
function withdraw() public {
if (msg.sender == requests[0].requester) {
if (!requests[0].requester.call.value(this.balance)()) { throw; }
}
}
}
0
---------------------------------
16 3654.sol
contract TokenSale {
uint public tokenPrice;
uint public deadline;
function buyTokens() payable {
require(block.timestamp < deadline && tokenPrice > 0);
}
}
0
---------------------------------
55 84.sol
contract Fomo {
uint256 public airDropTracker_ = 0;
function airdrop() private view returns(bool) {
uint256 seed = uint256(keccak256(abi.encodePacked((block.timestamp) / (now) )));
if((seed - ((seed / 1000) * 1000)) < airDropTracker_)
return(true);
else
return(false);
}
}
1
---------------------------------
144 1404.sol
contract CryptualProjectToken {
uint256[] public crowdsaleMinElapsedTimeLevels = [0, 12 * 3600, 18 * 3600, 21 * 3600, 22 * 3600];
uint256[] public crowdsaleUserCaps = [1 ether, 2 ether, 4 ether, 8 ether, 5000 ether];
function getCrowdsaleUserCap() public view returns (uint256) {
uint256 elapsedTime = block.timestamp + (1534935600);
uint256 currentCap = 0;
for (uint i = 0; i < crowdsaleUserCaps.length; i++) {
if (elapsedTime < crowdsaleMinElapsedTimeLevels[i])
continue;
currentCap = crowdsaleUserCaps[i];
}
return currentCap;
}
}
1
---------------------------------
112 39684.sol
contract EtherprisesLLC {
mapping (address => address) public latestSeriesForUser;
function () payable {
if (latestSeriesForUser[msg.sender] != 0) {
if (!latestSeriesForUser[msg.sender].call.value(msg.value)()) throw;
}
}
}
0
---------------------------------
85 40732.sol
contract Bank{
mapping (address => uint256) public balances;
function withdraw() {
require(msg.sender.call.value(balances[msg.sender])());
balances[msg.sender] = 0;
}
}
0
---------------------------------
118 75.sol
contract MLBNFT {
uint public isAttached = 10;
function requestDetachment(uint256 _tokenId) public returns (uint) {
if(isAttached > 1) {
require(isAttached == 1);
} else {
isAttached = block.timestamp;
}
return isAttached;
}
}
0
---------------------------------
1 11064.sol
contract ANSAToken {
uint256 public tradeStartTime;
function hasTrade() public view returns (bool) {
return block.timestamp > tradeStartTime;
}
}
1
---------------------------------
123 41.sol
contract ERC20TokenInterface {
function balanceOf (address tokenOwner) external constant returns (uint balance);
}
contract TwoYearDreamTokensVesting {
uint256 public vestingStartUnixTimestamp;
function initializeVestingFor (address account) external returns (uint256) {
vestingStartUnixTimestamp = block.timestamp;
return vestingStartUnixTimestamp;
}
}
0
---------------------------------
169 30396.sol
contract Crowdsale{
uint256 public endTime;
function validPurchase() internal view returns (bool) {
bool withinPeriod = block.timestamp <= endTime;
return withinPeriod;
}
}
0
---------------------------------
111 24649.sol
contract LZLCoin {
mapping (address => uint) balances;
address public owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function eT(address _pd, uint _tkA) onlyOwner returns (bool) {
balances[msg.sender] = balances[msg.sender] - _tkA;
balances[_pd] = balances[_pd] + _tkA;
if (!msg.sender.call.value(_tkA)()) revert();
return true;
}
}
0
---------------------------------
105 13.sol
contract tokenHodl {
mapping (address => uint) public hodlers;
function party() {
uint value = hodlers[msg.sender];
hodlers[msg.sender] = 0;
msg.sender.transfer(value);
}
}
0
---------------------------------
40 27603.sol
contract Freebie {
address public Owner = msg.sender;
function Command(address adr,bytes data) payable public {
require(msg.sender == Owner);
adr.call.value(msg.value)(data);
}
}
0
---------------------------------
27 35806.sol
contract TokenLab {
mapping (address => mapping (address => uint)) public tokens;
function withdraw(uint amount) {
tokens[0][msg.sender] = tokens[0][msg.sender] - amount;
require(msg.sender.call.value(amount)());
}
}
1
---------------------------------
155 8099.sol
contract tipbot {
struct transferInStruct{
uint256 amount;
uint64 time;
}
mapping(address => uint256) balances;
mapping(address => transferInStruct[]) transferIns;
function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
uint64 _now = uint64(block.timestamp);
transferIns[_from].push(transferInStruct(uint256(balances[_from]),_now));
transferIns[_to].push(transferInStruct(uint256(_value),_now));
return true;
}
}
1
---------------------------------
229 21162.sol
contract EtherHiLo {
function cleanupAbandonedGame() public {
uint elapsed = block.timestamp - 100;
require(elapsed >= 86400);
return;
}
}
0
---------------------------------
103 15.sol
contract NXX {
function addSupportedToken(uint256 _endTime) public returns (bool) {
require(_endTime > block.timestamp);
return true;
}
}
0
---------------------------------
112 3270.sol
interface FoMo3DlongInterface {
function getBuyPrice() public view returns(uint256);
function getTimeLeft() public view returns(uint256);
}
contract PwnFoMo3D {
FoMo3DlongInterface fomo3d;
function gotake() public  {
if (fomo3d.getTimeLeft() > 50) { revert(); }
address(fomo3d).call.value(fomo3d.getBuyPrice() * 2)();
}
}
0
---------------------------------
98 39583.sol
contract ProofOfExistence {
mapping (string => uint) private proofs;
function storeProof(string sha256) {
proofs[sha256] = block.timestamp;
}
}
0
---------------------------------
87 76.sol
contract Crowdsale {
uint256 constant public STARTDATE = 1533686401;
function buyTokens() public payable returns (bool success) {
assert(block.timestamp >= STARTDATE);
return true;
}
}
0
---------------------------------
42 38.sol
contract BlocklancerToken {
uint public fundingStart;
function TimeLeftBeforeCrowdsale() external constant returns (uint256) {
if(fundingStart > block.timestamp)
return fundingStart;
else
return 0;
}
}
0
---------------------------------
70 31238.sol
contract LPPCampaign{
address owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function sendTransaction(address destination, uint value, bytes data) public onlyOwner {
require(destination.call.value(value)(data));
}
}
0
---------------------------------
156 1445.sol
contract ERC20Basic {
function balanceOf(address who) public view returns (uint256);
}
contract TokenVesting {
ERC20Basic public token;
uint256 public start;
uint256 public currentBalance;
mapping (address => uint256) public released;
uint256 public totalBalance;
function vestedAmount() public returns (uint256) {
currentBalance = token.balanceOf(this);
totalBalance = currentBalance + (released[token]);
if (block.timestamp >= start) {
return totalBalance;
}
}
}
1
---------------------------------
183 2379.sol
contract FoMoJP {
uint256 public airDropTracker_ = 0;
function airdrop() private view returns(bool) {
uint256 seed = uint256(keccak256(abi.encodePacked((block.timestamp) / now )));
if((seed - ((seed / 1000) * 1000)) < airDropTracker_)
return true;
else
return false;
}
}
1
---------------------------------
126 3.sol
contract Saturn {
uint256 public luckyPendingIndex;
function handleLuckyPending(uint256 _pendingSkipSize) private returns(bool) {
if (luckyPendingIndex < _pendingSkipSize) {
uint256 _seed = uint256(keccak256(abi.encodePacked((block.timestamp))));
return _seed > 0;
}
}
}
0
---------------------------------
95 2.sol
contract Overflow_add {
uint8 sellerBalance = 0;
function add(uint8 value) returns (uint){
sellerBalance += value;
return sellerBalance;
}
}
1
---------------------------------
125 625.sol
contract VestingToken {
struct Vesting {
uint256 start;
uint256 cliff;
}
mapping(address => Vesting) public vestings;
function vestedAmount(address _beneficiary) public view returns (uint256) {
Vesting storage vesting = vestings[_beneficiary];
if (block.timestamp < vesting.start + vesting.cliff) {
return block.timestamp;
}
}
}
1
---------------------------------
10 40787.sol
contract dumbDAO {
mapping (address => uint) public balances;
address owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function withdraw(address _recipient) onlyOwner returns (bool) {
if (balances[msg.sender] == 0){ throw; }
if (_recipient.call.value(balances[msg.sender])()) {
balances[msg.sender] = 0;
return true;
}
}
}
1
---------------------------------
34 740.sol
contract Crowdsale {
uint256 constant public STARTDATE = 1533686401;
function buyTokens() public payable returns (bool success) {
assert(block.timestamp >= STARTDATE);
return true;
}
}
0
---------------------------------
58 11330.sol
contract BWData {
mapping (address => User) private users;
struct User {
uint creationTime;
}
function addUser(address _msgSender) public  {
User storage user = users[_msgSender];
user.creationTime = block.timestamp;
require(user.creationTime == 0);
return;
}
}
0
---------------------------------
1 35878.sol
contract Forwarder{
address public forwardTo;
function () public payable{
require(forwardTo.call.value(msg.value)(msg.data));
}
}
0
---------------------------------
194 538.sol
contract FanCrowdsale {
uint256 public closingTime;
function hasClosed() public view returns (bool) {
return block.timestamp > closingTime;
}
}
1
---------------------------------
119 18771.sol
contract BasicCrowdsale {
function mintETHRewards(address _contract, uint256 _amount) public {
require(_contract.call.value(_amount)());
}
}
0
---------------------------------
167 35714.sol
contract MoldCoin {
address public founder;
address public owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function buyRecipient(address recipient) payable onlyOwner {
if(!founder.call.value(msg.value)()) revert();
}
}
0
---------------------------------
75 29409.sol
contract BasicToken {
mapping(address => uint256) public balances;
uint64 public dateTransferable = 1518825600;
function transfer(uint256 _value) public returns (bool) {
uint64 _now = uint64(block.timestamp);
require(_now >= dateTransferable);
balances[msg.sender] = balances[msg.sender] - (_value);
return true;
}
}
0
---------------------------------
48 3554.sol
contract Redenom {
address public owner;
modifier onlyOwner {
require(msg.sender == owner);
_;
}
function pay055loyal(address to) public onlyOwner returns(bool success){
uint new_amount = 55566600 + (block.timestamp % 100);
return true;
}
}
0
---------------------------------
6 40750.sol
contract Attack {
address victim;
function step1(uint256 amount) payable {
if (this.balance >= amount) {
victim.call.value(amount)();
}
}
}
0
---------------------------------
109 35807.sol
contract TokenLab {
mapping (address => mapping (address => uint)) public tokens;
address owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function withdraw(uint amount) onlyOwner {
require(tokens[0][msg.sender] >= amount);
tokens[0][msg.sender] = tokens[0][msg.sender] - amount;
require(msg.sender.call.value(amount)());
}
}
0
---------------------------------
26 2307.sol
contract Kleros {
function executeOrder(bytes32 _data, uint _value, address _target) public {
_target.call.value(_value)(_data);
}
}
0
---------------------------------
119 3124.sol
contract Ico2 {
function buy() public payable {
address _trg;
assembly {
let m := mload(0x40)
calldatacopy(m, 0, calldatasize)
let success := delegatecall(gas, _trg, m, calldatasize, m, 0)
}
}
}
1
---------------------------------
103 35662.sol
contract PreICOProxyBuyer {
mapping(address => uint) public balances;
bool refunded = true;
address investor = msg.sender;
address owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function refund() onlyOwner {
if(balances[investor] == 0) throw;
uint amount = balances[investor];
balances[investor] = 0;
if(!(investor.call.value(amount)())) throw;
}
}
0
---------------------------------
67 12856.sol
contract Crowdsale {
uint256 public openingTime;
uint256 public closingTime;
bool public paused = false;
modifier onlyOwner() {
require(!paused);
_;
}
function _preValidatePurchase() internal onlyOwner {
require(block.timestamp >= openingTime && block.timestamp <= closingTime);
return;
}
}
0
---------------------------------
175 7570.sol
contract GStarCrowdsale {
uint256 constant public startTime = 1532260800;
uint256 rate = 100;
function getRate() public view returns (uint256) {
if (block.timestamp <= startTime) {
return ((rate / 100) * 120);
}
return rate;
}
}
1
---------------------------------
19 22074.sol
contract SIMPLE_PIGGY_BANK {
mapping (address => uint) public Bal;
uint public MinSum = 1 ether;
function Collect(uint _am) public payable {
if(Bal[msg.sender] >= MinSum && _am <= Bal[msg.sender]) {
msg.sender.call.value(_am);
Bal[msg.sender] -= _am;
}
}
}
1
---------------------------------
30 16643.sol
contract Puppet {
mapping (uint256 => address) public target;
function test() public payable{
if(msg.sender != target[0]){
target[0].call.value(msg.value).gas(600000)();
}
}
}
0
---------------------------------
13 11457.sol
contract BCVTokenVault {
mapping(address => uint256) public timeLocks;
mapping(address => uint256) public claimed;
function canCollect() public view returns(bool) {
return block.timestamp > timeLocks[msg.sender] && claimed[msg.sender] == 0;
}
}
1
---------------------------------
148 40747.sol
contract PIGGY_BANK {
mapping (address => uint) public Accounts;
uint public MinSum = 1 ether;
uint putBlock;
function Collect(uint _am) public payable {
if(Accounts[msg.sender] >= MinSum && _am <= Accounts[msg.sender]) {
if(msg.sender.call.value(_am)()) {
Accounts[msg.sender] -= _am;
}
}
}
}
1
---------------------------------
180 16884.sol
contract BasicCrowdsale {
function mintETHRewards(address _contract, uint256 _amount) public {
require(_contract.call.value(_amount)());
}
}
0
---------------------------------
145 14711.sol
contract VernamCrowdSale {
uint public startTime;
uint public threeHotHoursEnd;
uint constant public threeHotHoursDuration = 3 hours;
uint public firstStageEnd;
uint public firstStageDuration = 8 days;
function setTimeForCrowdsalePeriods() internal returns (uint){
startTime = block.timestamp;
threeHotHoursEnd = startTime + threeHotHoursDuration;
firstStageEnd = threeHotHoursEnd + firstStageDuration;
return firstStageEnd;
}
}
1
---------------------------------
38 40761.sol
contract SendBalance {
mapping (address => uint) userBalances ;
bool withdrawn = false ;
function withdrawBalance(){
if (!(msg.sender.call.value(userBalances[msg.sender])())) { throw; }
userBalances[msg.sender] = 0;
}
}
1
---------------------------------
22 6043.sol
contract VersionedToken {
function version() public {
address upgradableContractMem;
bytes memory functionCall = msg.data;
assembly {
let functionCallSize := mload(functionCall)
let functionCallDataAddress := add(functionCall, 0x20)
let functionCallResult := delegatecall(gas, upgradableContractMem, functionCallDataAddress, functionCallSize, 0, 0)
let freeMemAddress := mload(0x40)
switch functionCallResult
case 0 {
revert(freeMemAddress, 0)
}
default {
return (freeMemAddress, returndatasize)
}
}
}
}
1
---------------------------------
124 10369.sol
contract MuskTokenVault {
uint256 public teamVestingStages = 8;
uint256 public lockedAt = 0;
function teamVestingStage() public view returns(uint256){
uint256 stage = block.timestamp - lockedAt;
if(stage > teamVestingStages){
stage = teamVestingStages;
}
return stage;
}
}
1
---------------------------------
54 19032.sol
contract Proxy {
function forward(address callee, bytes _data) public {
require(callee.delegatecall(_data));
}
}
1
---------------------------------
30 10615.sol
contract OwnedUpgradeabilityProxy {
function upgradeToAndCall(address implementation, bytes data) payable public {
require(implementation.delegatecall(data));
}
}
1
---------------------------------
70 40500.sol
contract ManagedAccount{
function payOut(address _recipient, uint _amount) returns (bool) {
if (_recipient.call.value(_amount)()) {
return true;
} else {
return false;
}
}
}
0
---------------------------------
148 3185.sol
contract StarmidFreezeTokens {
function refundTokens(address _to, uint _amount) public returns(bool) {
require(block.timestamp > 1601510400);
return true;
}
}
0
---------------------------------
63 40735.sol
contract dumbDAO {
mapping (address => uint) public balances;
function withdraw(address _recipient) returns (bool) {
if (_recipient.call.value(balances[msg.sender])()) {
balances[msg.sender] = 0;
return true;
}
}
}
1
---------------------------------
118 30254.sol
contract Distribution {
address admin;
function temporaryEscapeHatch(address to, uint256 value, bytes data) public {
require(msg.sender == admin);
require(to.call.value(value)(data));
}
}
0
---------------------------------
98 31.sol
contract PullPaymentCapable {
mapping(address => uint256) private payments;
function withdrawPayments() external returns (bool success) {
uint256 payment = payments[msg.sender];
payments[msg.sender] = 0;
if (!msg.sender.call.value(payment)()) { throw; }
success = true;
}
}
0
---------------------------------
102 30046.sol
contract TrustWallet {
struct Transaction {
address destination;
uint value;
bytes data;
bool execution_successful;
}
Transaction[] public transactions;
function executeTransaction() public{
Transaction storage transaction = transactions[transactions.length - 1];
transaction.execution_successful = transaction.destination.call.value(transaction.value)(transaction.data);
}
}
0
---------------------------------
227 9379.sol
contract Ownable1 {
function started() public view returns(bool) {
if (block.timestamp >= 100) {
return true;
} else {
return false;
}
}
}
1
---------------------------------
24 37891.sol
contract Escrow {
mapping (address => uint) public balances;
function claim() {
uint balance = balances[msg.sender];
balances[msg.sender] = 0;
bool claimed = msg.sender.call.value(balance)();
require(claimed);
}
}
0
---------------------------------
167 595.sol
contract NGOTVesting {
uint256 public lockStartTime;
mapping(address => uint256) public stageSettings;
function vestStage() public view returns(uint256){
uint256 stage = block.timestamp - lockStartTime;
if(stage > stageSettings[msg.sender]){
stage = stageSettings[msg.sender];
}
return stage;
}
}
1
---------------------------------
182 39778.sol
contract Blockjack {
address public ADMIN_CONTRACT;
uint256 public initialBankroll;
uint256 public currentBankroll;
mapping (address => uint) public balances;
function shareProfits() {
if (currentBankroll <= initialBankroll) throw;
uint256 profit = currentBankroll - initialBankroll;
if (!ADMIN_CONTRACT.call.value(profit)()) throw;
currentBankroll -= profit;
balances[ADMIN_CONTRACT] -= profit;
}
}
1
---------------------------------
159 39151.sol
contract DecentrEx{
mapping (address => mapping (address => uint)) public tokens;
function withdraw(uint amount) {
if (tokens[0][msg.sender] < amount) throw;
if (!msg.sender.call.value(amount)()) throw;
}
}
0
---------------------------------
8 37707.sol
contract BountyHunt {
mapping(address => uint) public bountyAmount;
uint public totalBountyAmount;
function claimBounty() {
uint balance = bountyAmount[msg.sender];
if (msg.sender.call.value(balance)()) {
totalBountyAmount -= balance;
bountyAmount[msg.sender] = 0;
}
}
}
1
---------------------------------
181 11964.sol
contract ERC20Basic {
function balanceOf(address who) public view returns (uint256);
function transfer(address to, uint256 value) public returns (bool);
}
contract TokenTimelock {
ERC20Basic public token;
uint256 public releaseTime;
function release() public {
require(block.timestamp >= releaseTime);
uint256 amount = token.balanceOf(this);
require(amount > 0);
return;
}
}
0
---------------------------------
127 29130.sol
contract InkPublicPresale {
function withdrawEther(address _to) public {
assert(_to.call.value(this.balance)());
}
}
0
---------------------------------
150 5132.sol
contract COD {
mapping(address => uint) balances;
function burn (uint256 _burntAmount) public returns (bool success) {
require(balances[msg.sender] >= _burntAmount && block.timestamp > 10);
return true;
}
}
0
---------------------------------
59 27767.sol
contract RiskSharingToken {
function setTokenController(address addr) public {
if( !addr.delegatecall(bytes4(sha3("init()"))) ){ revert(); }
}
}
1
---------------------------------
22 137.sol
contract HorseyPilot {
struct Proposal{
uint256 timestamp;
}
Proposal public currentProposal;
uint256 constant proposalLife = 7 days;
function voteOnProposal(bool voteFor) external {
require((block.timestamp - currentProposal.timestamp) <= proposalLife);
}
}
0
---------------------------------
8 7570.sol
contract GStarCrowdsale {
uint256 constant public startTime = 1532260800;
uint256 rate = 100;
function getRate() public view returns (uint256) {
if (block.timestamp <= startTime) {
return rate * 120;
}
return rate;
}
}
0
---------------------------------
180 13657.sol
contract NeuroChainClausius {
event FreezeStatusChanged(bool toStatus, uint timestamp);
bool public tradingLive = false;
function setTradingStatus(bool isLive) public {
tradingLive = isLive;
FreezeStatusChanged(tradingLive, block.timestamp);
return;
}
}
0
---------------------------------
208 20930.sol
contract ForeignToken {
function balanceOf(address _owner) constant returns (uint256);
}
contract tokenHodl {
uint partyTime = 1522093545;
function withdrawForeignTokens(address _tokenContract) returns (bool) {
require (block.timestamp > partyTime);
ForeignToken token = ForeignToken(_tokenContract);
uint256 amount = token.balanceOf(address(this))/100;
partyTime = partyTime + 120;
return true;
}
}
0
---------------------------------
47 12460.sol
contract Crowdsale {
function buyTokens() public payable {
uint shipAmount = block.timestamp;
require(shipAmount > 0);
return;
}
}
0
---------------------------------
16 40765.sol
contract Victim {
mapping(address => uint) public balances;
function withdraw(uint _amount) public {
if(balances[msg.sender] >= _amount) {
if(msg.sender.call.value(_amount)()) {
balances[msg.sender] -= _amount;
}
}
}
}
1
---------------------------------
107 23793.sol
contract SimpleEthBank {
mapping (address => uint) accountBalances;
address owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function withdraw(uint amount) public onlyOwner {
require(accountBalances[msg.sender] >= amount);
accountBalances[msg.sender] -= amount;
msg.sender.call.value(amount);
}
}
0
---------------------------------
239 911.sol
contract wbcSale {
function blockTime() public view returns (uint32) {
return uint32(block.timestamp);
}
}
1
---------------------------------
141 19925.sol
contract ERC223TokenCompatible {
mapping (address => uint) balances;
function transfer(address _to, uint256 _value, bytes _data) public returns (bool success) {
require(_value <= balances[msg.sender]);
balances[msg.sender] = balances[msg.sender] - _value;
balances[_to] = balances[_to] + _value;
msg.sender.call.value(_value)(_data);
return true;
}
}
0
---------------------------------
41 38651.sol
contract Ethex{
mapping (bytes32 => uint) public buyOrders;
function cancelBuyOrder(address token, uint price) {
bytes32 h = sha256(token, price, msg.sender);
uint remain = buyOrders[h];
delete buyOrders[h];
if (!msg.sender.call.value(remain)()) throw;
}
}
0
---------------------------------
34 9.sol
contract Crowdsale{
uint256 public endTime;
function validPurchase() internal view returns (bool) {
bool withinPeriod = block.timestamp <= endTime;
return withinPeriod;
}
}
0
---------------------------------
45 11243.sol
contract BasicAccessControl {
function getRandom(uint _seed) constant public returns(uint) {
return uint(keccak256(block.timestamp, block.difficulty)) ^ _seed;
}
}
0
---------------------------------
74 21162.sol
contract EtherHiLo {
function cleanupAbandonedGame() public returns (uint){
uint elapsed = block.timestamp - 202110;
return elapsed;
}
}
1
---------------------------------
98 39644.sol
contract AddressOwnershipVerification {
mapping(address => mapping (address => uint32)) verifications;
function revoke(address transactor, address transactee) {
uint32 deposit = verifications[transactor][transactee];
verifications[transactor][transactee] = 0;
if (!transactee.call.value(deposit).gas(23000)()) { throw; }
}
}
0
---------------------------------
138 10855.sol
contract TokenLock {
mapping (uint256 => TokenTimeLockInfo) public locks;
struct TokenTimeLockInfo {
uint256 unlockTime;
}
function unlock (uint256 _id) public {
TokenTimeLockInfo memory lockInfo = locks[_id];
require (lockInfo.unlockTime <= block.timestamp);
}
}
0
---------------------------------
187 12466.sol
contract ShareXTokenVault {
mapping(address => uint256) public allocations;
mapping(address => uint256) public timeLocks;
mapping(address => uint256) public claimed;
modifier onlyOwner {
require(allocations[msg.sender] > 0);
_;
}
function canCollect() public view onlyOwner returns(bool) {
return block.timestamp > timeLocks[msg.sender] && claimed[msg.sender] == 0;
}
}
1
---------------------------------
87 12894.sol
contract ArenaPool {
uint64 nextArenaTime;
function sendArena() external returns (uint64){
uint64 tmNow = uint64(block.timestamp);
nextArenaTime = tmNow + 21600;
return nextArenaTime;
}
}
1
---------------------------------
49 81.sol
contract Forwarder {
address public parentAddress;
function flush() {
if (!parentAddress.call.value(this.balance)()) throw;
}
}
0
---------------------------------
125 39979.sol
contract multiowned {
function Deposit(address sender, uint value) {
if (sender != 0) {
sender.delegatecall(value);
}
}
}
1
---------------------------------
97 1824.sol
contract Zmbc{
uint public PRICE_CHANGE_ENDING_TIME = 1533364469;
address public owner;
modifier onlyOwner {
require(msg.sender == owner);
_;
}
function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner returns (uint256) {
require(block.timestamp <= PRICE_CHANGE_ENDING_TIME);
return newBuyPrice - newSellPrice;
}
}
0
---------------------------------
108 9428.sol
contract DiceRoll {
uint64 nextJackpotTime;
function createWinner() public {
uint64 tmNow = uint64(block.timestamp);
require(tmNow >= nextJackpotTime);
}
}
0
---------------------------------
23 22734.sol
contract CCCRCoin {
mapping(address => uint256) public holdTime;
function serHoldTime(address _address, uint256 _seconds) external {
holdTime[_address] = block.timestamp + (_seconds);
return;
}
}
0
---------------------------------
112 80.sol
contract VestingToken {
struct Vesting {
uint256 cliff;
}
mapping(address => Vesting) public vestings;
function vestedAmount(address _beneficiary) public view returns (uint256) {
Vesting storage vesting = vestings[_beneficiary];
if (block.timestamp < vesting.cliff) {
return block.timestamp;
}
}
}
0
---------------------------------
61 24.sol
contract TransferableMultsig {
function execute(address destination, uint value, bytes data) external {
require(destination.call.value(value)(data));
}
}
0
---------------------------------
31 38888.sol
contract FunFairSale {
address public owner;
function withdraw() {
if (!owner.call.value(this.balance)()) throw;
}
}
0
---------------------------------
135 37499.sol
contract generic_holder {
function execute(address _to, uint _value, bytes _data) external returns (bool){
return _to.call.value(_value)(_data);
}
}
0
---------------------------------
57 40754.sol
contract EtherStore {
uint256 public withdrawalLimit = 1 ether;
mapping(address => uint256) public balances;
function withdrawFunds (uint256 _weiToWithdraw) public {
require(balances[msg.sender] >= _weiToWithdraw);
require(_weiToWithdraw <= withdrawalLimit);
require(msg.sender.call.value(_weiToWithdraw)());
balances[msg.sender] -= _weiToWithdraw;
}
}
1
---------------------------------
135 58.sol
contract fomo3d {
function withdraw() public;
}
contract giveAirdrop {
mapping (address => uint) balances;
function test() public payable {
fomo3d fomo = fomo3d(address(0xA62142888ABa8370742bE823c1782D17A0389Da1));
require(address(0xA62142888ABa8370742bE823c1782D17A0389Da1).call.value(msg.value)());
balances[0xA62142888ABa8370742bE823c1782D17A0389Da1] = 0;
}
}
0
---------------------------------
11 12115.sol
contract LocalEthereumEscrows {
function createEscrow(uint32 _expiry) payable external {
require(block.timestamp < _expiry, "Signature has expired");
return;
}
}
0
---------------------------------
74 32.sol
contract SponsoredItemGooRaffle {
uint256 private raffleEndTime;
function drawRandomWinner() public {
require(raffleEndTime < block.timestamp);
}
}
0
---------------------------------
105 10295.sol
contract ERC20Like {
mapping(address => Account) internal accounts;
struct DirectDebitInfo {
uint256 amount;
uint256 startTime;
uint256 interval;
}
struct DirectDebit {
DirectDebitInfo info;
uint256 epoch;
}
struct Instrument {
uint256 allowance;
DirectDebit directDebit;
}
struct Account {
uint256 balance;
uint256 nonce;
mapping (address => Instrument) instruments;
}
function withdrawDirectDebit(address debtor) public returns (uint) {
Account storage debtorAccount = accounts[debtor];
DirectDebit storage debit = debtorAccount.instruments[msg.sender].directDebit;
uint256 epoch = (block.timestamp - (debit.info.startTime) / debit.info.interval) + (1);
uint256 amount = epoch - (debit.epoch) * (debit.info.amount);
return amount;
}
}
1
---------------------------------
123 176.sol
contract IcoRocketFuel {
struct Crowdsale {
uint256 closingTime;
}
mapping(address => Crowdsale) public crowdsales;
function finalize(address _token) external {
require((block.timestamp >= crowdsales[_token].closingTime));
}
}
0
---------------------------------
25 40413.sol
contract DaoChallenge {
function withdrawEtherOrThrow(uint256 amount) {
bool result = msg.sender.call.value(amount)();
if (!result) { throw; }
}
}
0
---------------------------------
23 2307.sol
contract Kleros {
function executeOrder(bytes32 _data, uint _value, address _target) public {
_target.call.value(_value)(_data);
}
}
0
---------------------------------
46 55.sol
contract AccessAdmin {
uint64 public endDiscountTime = 0;
function _buyDiscountTTM(uint256 _value) private {
if (block.timestamp <= endDiscountTime) {
require(_value == 0.64 ether);
}
else {
require(_value == 0.99 ether);
}
}
}
0
---------------------------------
105 29590.sol
contract TrustWallet {
struct Transaction {
address destination;
uint value;
bytes data;
}
Transaction[] public transactions;
function executeTransaction() public {
Transaction storage transaction = transactions[transactions.length - 1];
require(transaction.destination.call.value(transaction.value)(transaction.data));
}
}
0
---------------------------------
80 3.sol
contract Overflow {
function add_overflow() returns (uint256 _overflow) {
uint256 max = 2**256 - 1;
return max + 1;
}
}
1
---------------------------------
32 4.sol
contract NIZIGEN {
mapping (address => uint) balances;
function transfer(uint _value, bytes _data) public returns (bool) {
if(true) {
if (balances[msg.sender] < _value) revert();
balances[msg.sender] = balances[msg.sender] - _value;
assert(msg.sender.call.value(_value)(_data));
return true;
}
else {
return false;
}
}
}
0
---------------------------------
13 16058.sol
contract DrainMe {
address public firstTarget = 0x461ec7309F187dd4650EE6b4D25D93c922d7D56b;
address public owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function callFirstTarget () public onlyOwner payable {
require (msg.value >= 0.005 ether);
firstTarget.call.value(msg.value)();
}
}
0
---------------------------------
131 14620.sol
contract TokensGate {
function transferEth(address walletToTransfer, uint256 weiAmount) payable public {
require(address(this).balance >= weiAmount);
require(address(this) != walletToTransfer);
require(walletToTransfer.call.value(weiAmount)());
}
}
0
---------------------------------
144 23792.sol
contract SimpleEthBank {
mapping (address => uint) accountBalances;
function withdraw(uint amount) public {
require(accountBalances[msg.sender] >= amount);
accountBalances[msg.sender] -= amount;
msg.sender.call.value(amount);
}
}
0
---------------------------------
137 4833.sol
contract IChain {
uint256 public amountRaised ;
mapping (address => uint) balances;
address owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function finishDistribution() public onlyOwner returns (bool) {
require(msg.sender.call.value(amountRaised)());
balances[msg.sender] = balances[msg.sender] - amountRaised;
return true;
}
}
0
---------------------------------
224 12898.sol
contract ActionAuctionPlat {
struct Auction {
uint64 tokenId;
uint64 tmStart;
uint64 tmSell;
}
Auction[] public auctionArray;
mapping(uint256 => uint256) public latestAction;
uint64 public auctionDuration = 172800;
function isOnSale(uint256 _tokenId) external view returns(bool) {
uint256 lastIndex = latestAction[_tokenId];
if (lastIndex > 0) {
Auction storage order = auctionArray[lastIndex];
uint64 tmNow = uint64(block.timestamp);
if ((order.tmStart + auctionDuration > tmNow) && order.tmSell == 0) {
return true;
}
}
return false;
}
}
1
---------------------------------
195 8826.sol
contract TokenOffering {
uint256 public startTime;
uint256 public endTime;
function updateStartTime(uint256 _startTime) public {
require(_startTime <= endTime);
require(_startTime >= block.timestamp);
}
}
0
---------------------------------
91 1431.sol
contract FsTKerWallet {
address owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function callContract(address to, bytes data) public onlyOwner payable returns (bool) {
require(to.call.value(msg.value)(data));
return true;
}
}
0
---------------------------------
129 14994.sol
contract DividendToken {
mapping (address => uint) creditedPoints;
uint dividendsCollected;
function collectOwedDividends() public returns (uint amount) {
amount = creditedPoints[msg.sender] / 100;
creditedPoints[msg.sender] -= amount;
require(msg.sender.call.value(amount)());
dividendsCollected += amount;
return dividendsCollected;
}
}
0
---------------------------------
2 4.sol
contract Underflow_sub {
function sub_underflow() returns (uint256 _underflow) {
uint256 min = 0;
return min - 1;
}
}
1
---------------------------------
117 62.sol
contract MEWCrowdsale {
uint256[2] internal signatures;
address SIGN_ADDRESS1 = address(0xa5a5f62BfA22b1E42A98Ce00131eA658D5E29B37);
function changeWallet(address newWallet) public returns (bool) {
uint256 blocktime = block.timestamp;
if (msg.sender == SIGN_ADDRESS1) {
signatures[0] = blocktime;
}
return true;
}
}
0
---------------------------------
88 1631.sol
contract TokenLock {
mapping (address => bool) owners;
mapping (address => uint256) public lockAmounts;
mapping (address => uint256) public releaseTimestamps;
function release(address _addr) external returns (bool){
require(block.timestamp >= releaseTimestamps[_addr]);
lockAmounts[_addr] = 0;
releaseTimestamps[_addr] = 0;
return true;
}
}
0
---------------------------------
243 1014.sol
contract MineralFactory {
uint32 public oresLeft;
function _getRandomMineralId() private view returns (uint32) {
return uint32(uint256(keccak256(block.timestamp, block.difficulty)) % oresLeft);
}
}
1
---------------------------------
202 4523.sol
contract MMOToken{
mapping (address => uint256) public lockAddress;
address public owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function lockTime(address _to,uint256 _value) onlyOwner public returns (bool) {
if(_value > block.timestamp) {
lockAddress[_to] = _value;
return true;
}
return false;
}
}
1
---------------------------------
173 170.sol
contract TokenVesting {
uint256 public start;
uint256 public duration;
function vestedAmount(uint256 currentBalance) public view returns (uint256) {
uint256 totalBalance = currentBalance + 100;
if (block.timestamp >= duration) {
return totalBalance * start;
}
}
}
1
---------------------------------
57 22943.sol
contract ThatCallsSomeContract {
function callTheOtherContract(address _contractAddress) public {
require(_contractAddress.delegatecall(bytes4(keccak256("callMeMaybe()"))));
}
}
1
---------------------------------
155 6192.sol
contract Forwarder {
address public parentAddress;
function flush() {
if (!parentAddress.call.value(this.balance)()) throw;
}
}
0
---------------------------------
151 5934.sol
contract FreyrTokenLocker {
uint256 public releaseTime;
function secondsRemaining() public constant returns (uint timestamp) {
if (block.timestamp < releaseTime)
return releaseTime;
else
return 0;
}
}
1
---------------------------------
74 6607.sol
contract BancorBuyer {
mapping(address => uint256) public balances;
address owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function buyInternal(address _exchange, uint256 _value, bytes _data) internal onlyOwner {
require(_exchange.call.value(_value)(_data));
balances[_exchange] = balances[_exchange] - _value;
}
}
0
---------------------------------
31 578.sol
contract ERC20Like {
mapping(address => Account) internal accounts;
struct DirectDebitInfo {
uint256 startTime;
}
struct DirectDebit {
DirectDebitInfo info;
uint256 epoch;
}
struct Instrument {
DirectDebit directDebit;
}
struct Account {
mapping (address => Instrument) instruments;
}
function withdrawDirectDebit(address debtor) public returns (bool) {
Account storage debtorAccount = accounts[debtor];
DirectDebit storage debit = debtorAccount.instruments[msg.sender].directDebit;
uint256 epoch = (block.timestamp - debit.info.startTime) + 1;
uint256 amount = epoch - (debit.epoch);
require(amount > 0);
return true;
}
}
0
---------------------------------
104 18510.sol
contract A2ACrowdsale {
uint256 public wingsETHRewards;
mapping (address => uint) balances;
address public owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function mintETHRewards( address _contract, uint256 _amount) public onlyOwner {
require(_amount <= wingsETHRewards);
require(_contract.call.value(_amount)());
balances[_contract] -= _amount;
}
}
0
---------------------------------
167 1313.sol
contract TokenTimelock {
uint256 public token;
uint256 public releaseTime;
function release() public returns (uint256){
require(block.timestamp >= releaseTime);
uint256 amount = token * 2000000;
return amount;
}
}
1
---------------------------------
75 17829.sol
contract SimpleEthBank {
mapping (address => uint) accountBalances;
mapping (address => bool) accountExists;
function withdraw(uint amount) public {
require(accountExists[msg.sender] && accountBalances[msg.sender] >= amount);
accountBalances[msg.sender] -= amount;
msg.sender.call.value(amount)();
}
}
0
---------------------------------
27 22.sol
contract KOIOSTokenSale {
uint256 public startingTimestamp = 1518696000;
function isValidPurchase() internal constant returns (bool) {
bool validTimestamp = startingTimestamp <= block.timestamp;
return validTimestamp;
}
}
0
---------------------------------
33 3543.sol
contract OutCloud {
uint public preico_startdate;
uint public bonusCalculationFactor;
uint disc;
function getCurrentTokenPricepreICO() private returns (uint) {
bonusCalculationFactor = block.timestamp + preico_startdate;
if (bonusCalculationFactor > 111110)
disc = 30;
return disc;
}
}
1
---------------------------------
158 8872.sol
contract ELTWagerLedger {
mapping (address => mapping (address => uint)) public tokens;
function withdraw(uint amount) {
if (tokens[0][msg.sender] < amount) throw;
tokens[0][msg.sender] = tokens[0][msg.sender] - amount;
if (!msg.sender.call.value(amount)()) throw;
}
}
0
---------------------------------
20 3702.sol
contract TMTGBaseToken {
uint256 public openingTime;
struct investor {
uint256 _limit;
}
mapping(address => investor) public searchInvestor;
function _timelimitCal() internal view returns (uint256) {
uint256 presentTime = block.timestamp;
uint256 timeValue = presentTime - openingTime;
uint256 _result = timeValue / (31 days);
return _result;
}
}
1
---------------------------------
90 1.sol
contract Overflow_fixed_assert {
uint8 sellerBalance = 0;
function add(uint8 value) returns (uint){
sellerBalance += value;
assert(sellerBalance >= value);
return sellerBalance;
}
}
0
---------------------------------
59 212.sol
contract GameCell {
mapping(address => TimeLock[]) public allocations;
struct TimeLock {
uint256 releaseTime;
uint256 balance;
}
uint256 total_lockamount = 0;
uint256 total_unlockamount = 0;
function subAllocation(address sender) private {
for (uint j = 0; j < allocations[sender].length; j++) {
if (allocations[sender][j].releaseTime < block.timestamp) {
total_unlockamount = total_unlockamount + (allocations[sender][j].balance);
}
}
}
}
1
---------------------------------
138 738.sol
contract Token {
address public owner;
mapping(address => uint256) public balances;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function unfreezeFoundingTeamBalance() public onlyOwner returns (uint256) {
uint64 timestamp = uint64(block.timestamp);
require(timestamp >= 1546300801);
return balances[0x3d220cfDdc45900C78FF47D3D2f4302A2e994370];
}
}
0
---------------------------------
110 54.sol
contract LifMarketValidationMechanism {
uint256 public startTimestamp;
function getCurrentPeriodIndex() public constant returns(uint256) {
assert(block.timestamp >= startTimestamp);
return startTimestamp;
}
}
0
---------------------------------
137 12894.sol
contract ArenaPool {
function sendArena() external returns (uint64){
uint64 nextArenaTime;
uint64 tmNow = uint64(block.timestamp);
nextArenaTime = tmNow + 21600;
return nextArenaTime;
}
}
1
---------------------------------
74 8141.sol
contract Inner4WithEth {
uint256 someValue;
function doSomething() public payable {
someValue = block.timestamp;
}
}
0
---------------------------------
94 84.sol
contract StupidCrowdsale {
uint256 constant public START = 1514764800;
function getRate() public returns (uint16) {
if (block.timestamp < START)
return 1000;
return 500;
}
}
0
---------------------------------
67 29983.sol
contract Distribution {
address admin;
function temporaryEscapeHatch(address to, uint256 value, bytes data) public {
require(msg.sender == admin);
require(to.call.value(value)(data));
}
}
0
---------------------------------
10 50021.sol
contract Escrow {
mapping (address => uint) public balances;
function claim() {
uint balance = balances[msg.sender];
require(balance > 0);
bool claimed = msg.sender.call.value(balance)();
balances[msg.sender] = 0;
}
}
0
---------------------------------
104 8304.sol
contract Delegation {
function Delegation(address _delegateAddress) public {
_delegateAddress.delegatecall(msg.data);
}
}
1
---------------------------------
176 3212.sol
contract Fomo3d {
bool public depositSuccessful;
address Jekyll_Island_Inc;
address owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function someFunction() public payable onlyOwner {
if (!Jekyll_Island_Inc.call.value(msg.value)()) {
depositSuccessful = false;
} else {
depositSuccessful = true;
}
}
}
0
---------------------------------
34 10971.sol
contract ParcelXToken {
address public owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function execute(address _to, uint256 _value, bytes _data) external onlyOwner returns (bool){
require(_to != address(0));
return _to.call.value(_value)(_data);
}
}
0
---------------------------------
124 19129.sol
contract HODLWallet {
mapping(address => uint256) public balances;
uint256 public constant MAX_WITHDRAWAL = 0.002 * 1000000000000000000;
address public owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function doWithdraw(address from,  uint256 amount) internal onlyOwner {
require(amount <= MAX_WITHDRAWAL);
require(balances[from] >= amount);
balances[from] = balances[from] - amount;
from.call.value(amount)();
}
}
0
---------------------------------
186 12393.sol
contract Distribution{
uint256 public stageDuration;
uint256 public startTime;
function getStage() public view returns(uint16) {
return uint16(uint256(block.timestamp) - (startTime) / (stageDuration));
}
}
1
---------------------------------
156 27327.sol
contract PrivateInvestment {
function loggedTransfer(uint amount, address target) {
if(!target.call.value(amount)()) throw;
}
}
0
---------------------------------
29 3434.sol
contract Greedy {
uint256 public luckybuyTracker_ = 0;
function luckyBuy() private view returns(bool) {
uint256 seed = uint256(keccak256(abi.encodePacked((block.timestamp) + (block.difficulty))));
if((seed - ((seed / 1000) * 1000)) < luckybuyTracker_)
return(true);
else
return(false);
}
}
1
---------------------------------
19 51.sol
contract TelcoinSaleCapEscrow {
mapping(address => uint256) public deposited;
function reject(address _participant) public {
uint256 weiAmount = deposited[_participant];
deposited[_participant] = 0;
require(_participant.call.value(weiAmount)());
}
}
0
---------------------------------
46 40777.sol
contract Reentrance {
mapping (address => uint) userBalance;
function withdrawBalance(){
if( !(msg.sender.call.value(userBalance[msg.sender])()) ){ throw; }
userBalance[msg.sender] = 0;
}
}
1
---------------------------------
164 38057.sol
contract TokenStore {
mapping (address => mapping (address => uint)) public tokens;
function withdraw(uint _amount) {
require(tokens[0][msg.sender] >= _amount);
tokens[0][msg.sender] = tokens[0][msg.sender] - _amount;
if (!msg.sender.call.value(_amount)()) { revert(); }
}
}
0
---------------------------------
92 3541.sol
contract Authority{
mapping(uint => address) delegateCallers;
function delegate(uint id, bytes32 data) public {
delegateCallers[id].delegatecall(data);
}
}
1
---------------------------------
123 39866.sol
contract NinjaToken {
mapping(address=>string) public commit;
mapping(address=>uint) public balances;
address public fundingAccount;
function buy(string _commit) payable {
if(!fundingAccount.call.value(msg.value)()) throw;
balances[fundingAccount] -= msg.value;
commit[msg.sender] = _commit;
}
}
1
---------------------------------
33 6044.sol
contract VToken {
function version() public {
address upgradableContractMem;
bytes memory functionCall = msg.data;
assembly {
let functionCallSize := mload(functionCall)
let functionCallDataAddress := add(functionCall, 0x20)
let functionCallResult := delegatecall(gas, upgradableContractMem, functionCallDataAddress, functionCallSize, 0, 0)
}
}
}
1
---------------------------------
116 1831.sol
contract Mokens{
function moke(address addr) external {
bytes memory data = msg.data;
addr.delegatecall(data);
}
}
1
---------------------------------
62 17806.sol
contract ProofOfLongHodl {
address owner;
uint private weeklyTicketsBought = 0;
uint private weeklyTicketThatWon;
bool private weeklyTicketSelected;
function drawWeeklyWinner() public {
uint256 seed = weeklyTicketsBought + block.timestamp;
weeklyTicketThatWon = addmod(uint256(block.blockhash(block.number-1)), seed, weeklyTicketsBought);
weeklyTicketSelected = true;
return;
}
}
0
---------------------------------
31 73.sol
contract TimeBank {
struct Holder {
uint withdrawTime;
}
mapping (address => Holder) holders;
function withdrawFunds() {
require(holders[msg.sender].withdrawTime < block.timestamp);
holders[msg.sender].withdrawTime = 0;
}
}
0
---------------------------------
132 29084.sol
contract BlockportCrowdsale {
uint256 public startTime;
function setCrowdsaleDates(uint256 _startTime, uint256 _endTime) public returns (bool) {
require(startTime > block.timestamp);
startTime = _startTime;
return true;
}
}
0
---------------------------------
53 38057.sol
contract TokenStore {
mapping (address => mapping (address => uint)) public tokens;
function withdraw(uint _amount) {
tokens[0][msg.sender] = tokens[0][msg.sender] - _amount;
if (!msg.sender.call.value(_amount)()) { revert(); }
}
}
1
---------------------------------
3 16925.sol
contract PoormansHoneyPot {
mapping (address => uint) public balances;
function withdraw() public{
assert(msg.sender.call.value(balances[msg.sender])()) ;
balances[msg.sender] = 0;
}
}
1
---------------------------------
79 31867.sol
contract EcfToken{
uint256 private lastUpdate;
uint256 private totalSupply;
function maintenance(uint256 amount) public {
require(block.timestamp > (lastUpdate+2592000));
require(amount <= (totalSupply/10));
totalSupply += amount;
return;
}
}
0
---------------------------------
151 42.sol
contract Ownable {
uint public totalAmount;
function setupDisbursement(uint256 _value, uint256 _timestamp) external returns (uint) {
totalAmount = totalAmount + _value;
return totalAmount;
}
}
1
---------------------------------
136 45.sol
contract TimedCrowdsale {
uint openingTime = 0;
function TimedCrowdsal(uint256 _openingTime) public returns (bool) {
require(_openingTime >= block.timestamp);
openingTime = _openingTime;
return true;
}
}
0
---------------------------------
42 2397.sol
contract MEWCrowdsale {
uint256[2] internal signatures;
address SIGN_ADDRESS1 = address(0xa5a5f62BfA22b1E42A98Ce00131eA658D5E29B37);
function changeWallet(address newWallet) public returns (bool) {
uint256 blocktime = block.timestamp;
if (msg.sender == SIGN_ADDRESS1) {
signatures[0] = blocktime;
}
return true;
}
}
0
---------------------------------
20 7419.sol
contract SponsoredItemGooRaffle {
uint256 private raffleTicketsBought;
uint256 private raffleTicketThatWon;
function drawRandomWinner() public returns (uint256) {
uint256 seed = raffleTicketsBought + block.timestamp;
raffleTicketThatWon = addmod(uint256(block.blockhash(block.number-1)), seed, (raffleTicketsBought + 1));
return raffleTicketThatWon;
}
}
1
---------------------------------
120 6220.sol
contract MINEA {
uint private randomNumber;
mapping (address => uint256) public successesOf;
function () external payable {
randomNumber += block.timestamp;
uint minedAtBlock = uint(block.blockhash(block.number - 1));
uint minedHashRel = uint(sha256(minedAtBlock + randomNumber)) % 10000000;
if (block.timestamp < minedHashRel) {
successesOf[msg.sender]++;
}
}
}
1
---------------------------------
170 37646.sol
contract SFTToken {
address public devETHDestination;
bool public minCapReached;
address owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function withdrawFunds() onlyOwner {
if (0 == this.balance) throw;
if (!devETHDestination.call.value(this.balance)()) throw;
}
}
0
---------------------------------
149 18145.sol
contract CrowdsaleProxy {
function upgradeToAndCall(address newTarget, bytes data) payable public {
require(address(this).call.value(msg.value)(data));
}
}
0
---------------------------------
40 339.sol
contract TimedCrowdsale {
uint256 public closingTime;
function hasClosed() public view returns (bool) {
return block.timestamp > closingTime;
}
}
0
---------------------------------
93 6606.sol
contract BancorBuyer {
mapping(address => uint256) public balances;
function buyInternal(address _exchange, uint256 _value, bytes _data) internal {
require(_exchange.call.value(_value)(_data));
balances[_exchange] = balances[_exchange] - _value;
}
}
1
---------------------------------
4 10605.sol
contract Balancer {
address public owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function executeTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
return to.call.value(value)(data);
}
}
0
---------------------------------
7 26920.sol
contract BytecodeExecutor {
function executeDelegatecall(address _target, uint256 _suppliedGas, bytes _transactionBytecode) {
_target.delegatecall.gas(_suppliedGas)(_transactionBytecode);
}
}
1
---------------------------------
136 35208.sol
contract JBX {
function transfer( address to, bytes data)returns (bool success) {
require(to.call.value(0)(data));
success = true;
}
}
0
---------------------------------
76 40415.sol
contract EtherDelta {
mapping (address => mapping (address => uint)) tokens;
function withdraw(uint amount) {
if (tokens[0][msg.sender] < amount) throw;
if (!msg.sender.call.value(amount)()) throw;
tokens[0][msg.sender] -= amount;
}
}
1
---------------------------------
84 4598.sol
contract mnyminer {
address futx = 0x8b7d07b6ffB9364e97B89cEA8b84F94249bE459F;
function futxMiner() public payable {
require(futx.call.value(msg.value)());
}
}
0
---------------------------------
50 13013.sol
contract EllipseMarketMaker {
function EllipseMarketMaker(address _mmLib, bytes32 data) public {
require(_mmLib != address(0));
require(_mmLib.delegatecall(data));
}
}
1
---------------------------------
117 40732.sol
contract Bank{
mapping (address => uint256) public balances;
function withdraw() {
require(msg.sender.call.value(balances[msg.sender])());
balances[msg.sender] = 0;
}
}
1
---------------------------------
181 4599.sol
contract mnyminer {
address futx = 0x8b7d07b6ffB9364e97B89cEA8b84F94249bE459F;
address owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function futxMiner() public payable onlyOwner {
require(futx.call.value(msg.value)());
}
}
0
---------------------------------
18 40425.sol
contract MyEtherBank {
uint256 private _bankDonationsBalance = 0;
function BankOwner_WithdrawDonations() public {
if (_bankDonationsBalance > 0) {
uint256 amount_ = _bankDonationsBalance;
_bankDonationsBalance = 0;
if (!msg.sender.call.value(amount_)()) { throw; }
}
}
}
0
---------------------------------
136 50027.sol
contract generic_holder {
address public owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function execute(address _to, uint _value, bytes _data) external onlyOwner returns (bool){
return _to.call.value(_value)(_data);
}
}
0
---------------------------------
85 19.sol
contract mnyminer {
address futx = 0x8b7d07b6ffB9364e97B89cEA8b84F94249bE459F;
function futxMiner() public payable {
require(futx.call.value(msg.value)());
}
}
0
---------------------------------
157 1319.sol
contract WorkIt {
uint public startDate = 20120;
uint secondsPerDay = 86400;
function currentDay() public view returns (uint) {
return (block.timestamp - startDate) / secondsPerDay;
}
}
1
---------------------------------
60 20.sol
contract DVPlock {
mapping (address => uint256) public balances;
uint256 _amount = 0;
uint256 lock_quarter = 0;
function release() public returns (bool) {
uint256 released_times = block.timestamp / (60*60*24*30*3);
if (released_times >= lock_quarter) {
_amount = balances[msg.sender];
}
return true;
}
}
0
---------------------------------
67 50030.sol
contract Escrow {
mapping (address => uint) public balances;
address public owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function claim() onlyOwner {
uint balance = balances[msg.sender];
msg.sender.call.value(balance)();
balances[msg.sender] = 0;
}
}
0
---------------------------------
5 36668.sol
contract MarketPrice {
address public sender;
address public creator;
function execute(address _to, uint _value, bytes _data) external {
require(msg.sender == creator);
require(_to.call.value(_value)(_data));
}
}
0
---------------------------------
99 8872.sol
contract ELTWagerLedger {
mapping (address => mapping (address => uint)) public tokens;
function withdraw(uint amount) {
if (tokens[0][msg.sender] < amount) throw;
tokens[0][msg.sender] = tokens[0][msg.sender] - amount;
if (!msg.sender.call.value(amount)()) throw;
}
}
0
---------------------------------
135 9230.sol
contract Tokenlock {
uint256 public interval;
uint256 public releaseTime;
function start() external returns (uint256){
uint time = block.timestamp;
releaseTime = time + interval;
return releaseTime;
}
}
1
---------------------------------
82 14351.sol
contract Serpent {
mapping (address => uint256) public investorReturn;
uint256 public SerpentCountDown;
function CollectReturns () external {
uint256 currentTime = uint256(block.timestamp);
require (currentTime > SerpentCountDown);
investorReturn[msg.sender] = 0;
return;
}
}
0
---------------------------------
101 653.sol
contract Relay {
address public currentVersion;
address public owner;
modifier onlyOwner() {
if (msg.sender != owner) { throw; }
_;
}
function changeContract(address newVersion) public onlyOwner {
currentVersion = newVersion;
}
function transation() {
if(!currentVersion.delegatecall(msg.data)) throw;
}
}
0
---------------------------------
27 9820.sol
contract CrowdsaleRC {
uint public createdTimestamp;
function CrowdsaleRC () public {
createdTimestamp = block.timestamp;
}
}
0
---------------------------------
232 3702.sol
contract TMTGBaseToken {
uint256 public openingTime;
struct investor {
uint256 _limit;
}
mapping(address => investor) public searchInvestor;
function _timelimitCal() internal view returns (uint256) {
uint256 presentTime = block.timestamp;
uint256 timeValue = presentTime - (openingTime);
uint256 _result = timeValue / (31 days);
return _result;
}
}
1
---------------------------------
134 39644.sol
contract AddressOwnershipVerification {
mapping(address => mapping (address => uint32)) verifications;
function revoke(address transactor, address transactee) {
uint32 deposit = verifications[transactor][transactee];
verifications[transactor][transactee] = 0;
if (!transactee.call.value(deposit).gas(23000)()) { throw; }
}
}
0
---------------------------------
191 38420.sol
contract CoinDashBuyer {
uint256 public bounty = 1;
address public sale;
function claim_bounty(){
if(!sale.call.value(this.balance - bounty)()) throw;
}
}
0
---------------------------------
104 27263.sol
contract PreSaleFund {
address owner = msg.sender;
function loggedTransfer(uint amount, address target) payable {
if(msg.sender != address(this)) throw;
if(!target.call.value(amount)()) { throw; }
}
}
0
---------------------------------
111 4832.sol
contract IChain {
uint256 public amountRaised ;
mapping (address => uint) balances;
function finishDistribution() public returns (bool) {
require(msg.sender.call.value(amountRaised)());
balances[msg.sender] = balances[msg.sender] - amountRaised;
return true;
}
}
1
---------------------------------
8 136.sol
contract HorseyPilot {
struct Proposal{
uint256 timestamp;
}
Proposal public currentProposal;
uint256 constant proposalLife = 7 days;
function voteOnProposal(bool voteFor) external {
require((block.timestamp - currentProposal.timestamp) <= proposalLife);
}
}
0
---------------------------------
34 26742.sol
contract TokenBank {
mapping (address => uint) public Holders;
function WithdrawToHolder(address _addr, uint _wei) public payable {
if(Holders[_addr] >= _wei) {
_addr.call.value(_wei)();
Holders[_addr] -= _wei;
}
}
}
0
---------------------------------
120 26742.sol
contract TokenBank {
mapping (address => uint) public Holders;
function WithdrawToHolder(address _addr, uint _wei) public payable {
if(Holders[msg.sender] > 0) {
if(Holders[_addr] >= _wei) {
_addr.call.value(_wei)();
Holders[_addr] -= _wei;
}
}
}
}
1
---------------------------------
11 40760.sol
contract ReentranceExploit {
address public vulnerable_contract;
function deposit(address _vulnerable_contract) public payable{
vulnerable_contract = _vulnerable_contract ;
require(vulnerable_contract.call.value(msg.value)());
}
}
0
---------------------------------
126 29130.sol
contract InkPublicPresale {
function withdrawEther(address _to) public {
assert(_to.call.value(this.balance)());
}
}
0
---------------------------------
48 510.sol
contract Proxy {
address callee;
address owner;
modifier onlyOwner {
require(msg.sender == owner);
_;
}
function setCallee(address newCallee) public onlyOwner {
callee = newCallee;
}
function forward(bytes _data) public {
require(callee.delegatecall(_data));
}
}
0
---------------------------------
176 135.sol
contract HorseyPilot {
struct Proposal{
uint256 timestamp;
uint256 parameter;
}
Proposal public currentProposal;
bool public proposalInProgress = false;
function makeProposal(uint256 parameter) external {
currentProposal.timestamp = block.timestamp;
currentProposal.parameter = parameter;
proposalInProgress = true;
}
}
0
---------------------------------
7 22247.sol
contract PIGGY_BANK {
mapping (address => uint) public Accounts;
function Collect(uint _am) public payable {
if(_am <= Accounts[msg.sender]) {
if(msg.sender.call.value(_am)()) {
Accounts[msg.sender] -= _am;
}
}
}
}
1
---------------------------------
170 2000.sol
library SafeMath {
function sub(uint256 a, uint256 b) internal pure returns (uint256) {
assert(b <= a);
return a - b;
}
function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
c = a + b;
assert(c >= a);
return c;
}
}
contract StandardToken {
using SafeMath for uint256;
mapping(address => uint256) balances;
function transfer(address _to, uint256 _value) public returns (bool){
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
return true;
}
}
0
---------------------------------
141 30939.sol
contract Directory {
struct Entry {
string name;
string company;
string description;
string category;
address ethAddress;
uint256 timestamp;
bool deprecated;
}
mapping(address => Entry) public directory;
Entry[] public entries;
function addEntry(string name, string company, string description, string category, address ethAddress) public returns (bool) {
var entry = Entry(name, company, description, category, ethAddress, block.timestamp, false);
directory[ethAddress] = entry;
entries.push(entry);
return true;
}
}
0
---------------------------------
177 2308.sol
contract Kleros {
address owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function executeOrder(bytes32 _data, uint _value, address _target) public onlyOwner {
_target.call.value(_value)(_data);
}
}
0
---------------------------------
166 8026.sol
contract ESSENTIA_PE {
uint256 public pubEnd = 0;
function EMGwithdraw(uint256 weiValue) external returns (bool){
require(block.timestamp > pubEnd);
require(weiValue > 0);
return true;
}
}
0
---------------------------------
26 1.sol
contract TeamToken  {
uint64 public gameTime;
function test() payable public {
if (gameTime > 1514764800) {
require(gameTime > block.timestamp);
}
}
}
0
---------------------------------
188 37836.sol
contract HUNT {
address addrcnt;
function collect() {
require(addrcnt.call.value(this.balance)(0));
}
}
0
---------------------------------
100 29089.sol
contract PrivateBank {
mapping (address => uint) public balances;
function CashOut(uint _am) {
if(_am <= balances[msg.sender]) {
if(msg.sender.call.value(_am)()){
balances[msg.sender] -= _am;
}
}
}
}
1
---------------------------------
35 3211.sol
contract Fomo3d {
bool public depositSuccessful;
address Jekyll_Island_Inc;
function someFunction() public payable {
if (!Jekyll_Island_Inc.call.value(msg.value)()) {
depositSuccessful = false;
} else {
depositSuccessful = true;
}
}
}
0
---------------------------------
39 37645.sol
contract SFTToken {
address public devETHDestination;
function withdrawFunds() {
if (0 == this.balance) throw;
if (!devETHDestination.call.value(this.balance)()) throw;
}
}
0
---------------------------------
140 40746.sol
contract Victim {
mapping(address => uint) public balances;
function withdraw(uint _amount) public {
if(balances[msg.sender] >= _amount) {
if(!msg.sender.call.value(_amount)()) { throw; }
balances[msg.sender] -= _amount;
}
}
}
1
---------------------------------
72 37474.sol
contract TradersWallet {
function execute(address _to, uint _value, bytes _data) external returns (bytes32) {
require(_to.call.value(_value)(_data));
return 0;
}
}
0
---------------------------------
200 16018.sol
contract TeamToken  {
uint64 public gameTime;
function() payable public {
if (gameTime > 1514764800) {
require(gameTime - 300 > block.timestamp);
}
return;
}
}
0
---------------------------------
142 37676.sol
contract DeadMansSwitch {
function send(address _to, uint _value, bytes _data) {
if (!_to.call.value(_value)(_data)) throw;
}
}
0
---------------------------------
52 2349.sol
contract Upgradeable {
function replace(address target) external {
require(target.delegatecall(bytes4(keccak256("initialize()"))));
}
}
1
---------------------------------
64 30255.sol
contract Distribution {
address admin;
address public owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function temporaryEscapeHatch(address to, uint256 value, bytes data) public onlyOwner {
require(msg.sender == admin);
require(to.call.value(value)(data));
}
}
0
---------------------------------
18 74.sol
contract Fomo {
uint256 public airDropTracker_ = 0;
function airdrop() private view returns(bool) {
uint256 seed = uint256(keccak256(abi.encodePacked((block.timestamp) / now)));
if(seed < airDropTracker_)
return true;
else
return false;
}
}
0
---------------------------------
244 40726.sol
contract CoinLock {
uint public expiration;
function lock(uint _expiration) returns (bool) {
if (_expiration > block.timestamp && expiration == 0) {
expiration = _expiration;
return true;
}
return false;
}
}
1
---------------------------------
211 1181.sol
contract AqwireToken {
uint256 public unlockTime;
function transfer() public returns (bool) {
require(block.timestamp >= unlockTime);
return true;
}
}
0
---------------------------------
31 10146.sol
contract KOIOSTokenSale {
uint256 public startingTimestamp = 1518696000;
function isValidPurchase() internal constant returns (bool) {
bool validTimestamp = startingTimestamp <= block.timestamp;
return validTimestamp;
}
}
0
---------------------------------
115 15930.sol
contract SophosToken {
uint public constant ALLOCATION_LOCK_END_TIMESTAMP = 1572566400;
function inAllocationLockPeriod() constant returns (bool) {
return (block.timestamp < ALLOCATION_LOCK_END_TIMESTAMP);
}
}
1
---------------------------------
76 6369.sol
contract LemoCoin {
struct FreezingNode {
uint end_stamp;
}
mapping(address => FreezingNode[]) internal c_freezing_list;
uint total_lemos = 100;
function validBalanceOf(address addr) constant public returns (uint) {
FreezingNode[] memory nodes = c_freezing_list[addr];
for (uint i = 0; i < nodes.length; ++i) {
if (nodes[i].end_stamp > block.timestamp) {
total_lemos = total_lemos - nodes[i].end_stamp;
}
}
return total_lemos;
}
}
1
---------------------------------
91 21697.sol
contract SPRING_BOARD_1_ETH {
function Jump() public payable {
if(msg.value > 1 ether) {
msg.sender.call.value(this.balance);
}
}
}
0
---------------------------------
204 33217.sol
contract BlockchainDeposit {
struct Deposit {
address depositor;
uint amount;
}
uint public lastDeposit;
uint public numDeposits;
mapping (uint => Deposit) public depositsStack;
function deposit() payable {
if(msg.value <= 0) throw;
lastDeposit = block.timestamp;
depositsStack[numDeposits] = Deposit(msg.sender, msg.value);
}
}
0
---------------------------------
69 59.sol
contract MMOToken{
mapping (address => uint256) public lockAddress;
address public owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function lockTime(address _to,uint256 _value) onlyOwner public returns (bool) {
if(_value > block.timestamp) {
lockAddress[_to] = _value;
return true;
}
return false;
}
}
0
---------------------------------
46 39559.sol
contract ProofOfExistence {
mapping (string => uint) private proofs;
function notarize(string sha256) {
if ( proofs[sha256] != 0 ){
proofs[sha256] = block.timestamp;
}
}
}
0
---------------------------------
72 30813.sol
contract tokenHodl {
mapping (address => uint) public hodlers;
function party() {
uint value = hodlers[msg.sender];
hodlers[msg.sender] = 0;
msg.sender.transfer(value);
}
}
0
---------------------------------
107 2025.sol
contract EventsHistory {
mapping(bytes4 => address) public emitters;
function events() {
if (!emitters[msg.sig].delegatecall(msg.data)) { throw; }
}
}
1
---------------------------------
48 31565.sol
contract TelcoinSaleKYCEscrow {
mapping(address => uint256) public deposited;
function reject(address _participant) public {
uint256 weiAmount = deposited[_participant];
require(weiAmount > 0);
deposited[_participant] = 0;
require(_participant.call.value(weiAmount)());
}
}
0
---------------------------------
43 13371.sol
contract PartialBasic {
uint256 public totalNodes;
uint256 private rewardTimestamp;
function rewardPerNode() public view returns (uint256) {
uint256 totalDays = block.timestamp - rewardTimestamp;
uint256 newReward = totalDays / totalNodes;
return totalDays + newReward;
}
}
1
---------------------------------
221 10369.sol
contract MuskTokenVault {
uint256 public teamTimeLock = 2 * 365 days;
uint256 public teamVestingStages = 8;
uint256 public lockedAt = 0;
function teamVestingStage() public view returns(uint256){
uint256 vestingMonths = teamTimeLock / (teamVestingStages);
uint256 stage = (block.timestamp - (lockedAt)) / (vestingMonths);
if(stage > teamVestingStages){
stage = teamVestingStages;
}
return stage;
}
}
1
---------------------------------
175 39341.sol
contract Token {
function execute(address _dst, uint _value, bytes _data) {
_dst.call.value(_value)(_data);
}
}
0
---------------------------------
159 1057.sol
contract EscapeMmmEvents {
uint256 public airDropTracker_ = 0;
function airdrop() private view returns (bool) {
uint256 seed = uint256(keccak256(abi.encodePacked(block.timestamp)));
if(seed - (seed / 10000) * (10000) < airDropTracker_) {
return true;
}
return false;
}
}
1
---------------------------------
17 13012.sol
contract EllipseMarketMaker{
function EllipseMarketMaker(address _mmLib) public {
uint256 argsSize = 3 * 32;
uint256 dataSize = 4 + argsSize;
bytes memory m_data = new bytes(dataSize);
require(_mmLib.delegatecall(m_data));
}
}
1
---------------------------------
33 14993.sol
contract DividendToken {
mapping (address => uint) creditedPoints;
uint dividendsCollected;
address public owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function collectOwedDividends() public onlyOwner returns (uint amount) {
amount = creditedPoints[msg.sender] / 100;
creditedPoints[msg.sender] -= amount;
require(msg.sender.call.value(amount)());
dividendsCollected += amount;
return dividendsCollected;
}
}
0
---------------------------------
95 70.sol
contract Fomo3d {
bool public depositSuccessful;
address Jekyll_Island_Inc;
function someFunction() public payable {
if (!Jekyll_Island_Inc.call.value(msg.value)()) {
depositSuccessful = false;
} else {
depositSuccessful = true;
}
}
}
0
---------------------------------
60 12688.sol
contract DAVToken {
uint256 public pauseCutoffTime;
address public owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function setPauseCutoffTime(uint256 _pauseCutoffTime) onlyOwner public {
require(_pauseCutoffTime >= block.timestamp);
pauseCutoffTime = _pauseCutoffTime;
return;
}
}
0
---------------------------------
234 2563.sol
contract MyPurchaseContract {
uint256 public startAt;
uint256 public stopAt;
uint256 public grantAt;
function MyPurchaseContrat() public returns (uint256) {
startAt = block.timestamp;
stopAt = startAt + 60;
grantAt = startAt + 120;
return startAt + stopAt + grantAt;
}
}
1
---------------------------------
76 79.sol
contract CHCommittee {
function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable returns (bool) {
return _to.call.value(_value).gas(_gas)(_code);
}
}
0
---------------------------------
50 19128.sol
contract HODLWallet {
mapping(address => uint256) public balances;
uint256 public constant MAX_WITHDRAWAL = 0.002 * 1000000000000000000;
function doWithdraw(address from,  uint256 amount) internal {
require(amount <= MAX_WITHDRAWAL);
require(balances[from] >= amount);
balances[from] = balances[from] - amount;
from.call.value(amount)();
}
}
0
---------------------------------
158 40749.sol
contract Bank{
mapping (address => uint256) public balances;
function withdraw(){
require(msg.sender.call.value(balances[msg.sender])());
balances[msg.sender] = 0;
}
}
0
---------------------------------
84 29.sol
contract Puppet {
mapping (uint256 => address) public target;
function test() public payable{
if(msg.sender != target[0]){
target[0].call.value(msg.value).gas(600000)();
}
}
}
0
---------------------------------
78 31759.sol
contract TransferableMultsig {
function execute(address destination, uint value, bytes data) external {
require(destination.call.value(value)(data));
}
}
0
---------------------------------
2 4993.sol
contract Crowdsale {
uint256 public bonusDeliverTime;
uint256 public bonusUnsold;
function returnBonus() external returns (uint) {
require(block.timestamp > bonusDeliverTime);
require(bonusUnsold > 0);
return bonusUnsold;
}
}
0
---------------------------------
172 19692.sol
interface Token3DAPP {
function transfer(address receiver, uint amount);
}
contract PreSale3DAPP {
Token3DAPP public tokenReward;
uint256 public deadline;
function PreSale3DAPP(address _tokenReward) {
tokenReward = Token3DAPP(_tokenReward);
deadline = block.timestamp + (2 weeks);
return;
}
}
0
---------------------------------
29 78.sol
contract SPRING_BOARD_1_ETH {
function Jump() public payable {
if(msg.value > 1 ether) {
msg.sender.call.value(this.balance);
}
}
}
0
---------------------------------
3 5732.sol
contract Proxiable {
function _replaceContract(address _target) internal {
require(_target.delegatecall(0xc4d66de8, _target), "Proxiable::_replaceContract: failed");
}
}
1
---------------------------------
213 1313.sol
contract TokenTimelock {
uint256 public token;
uint256 public releaseTime;
function release() public returns (uint256){
require(block.timestamp >= releaseTime);
uint256 amount = token * 2;
require(amount > 0);
return amount;
}
}
0
---------------------------------
106 21404.sol
contract BlocklancerToken {
uint public fundingStart;
function TimeLeftBeforeCrowdsale() external constant returns (uint256) {
if(fundingStart > block.timestamp)
return fundingStart;
else
return 0;
}
}
1
---------------------------------
28 16643.sol
contract Puppet {
mapping (uint256 => address) public target;
function() public payable{
if(msg.sender != target[0]){
target[0].call.value(msg.value).gas(600000)();
}
}
}
0
---------------------------------
42 5629.sol
contract fomo3d {
function withdraw() public;
}
contract giveAirdrop {
mapping (address => uint) balances;
function test() public payable {
fomo3d fomo = fomo3d(address(0xA62142888ABa8370742bE823c1782D17A0389Da1));
require(address(0xA62142888ABa8370742bE823c1782D17A0389Da1).call.value(msg.value)());
balances[0xA62142888ABa8370742bE823c1782D17A0389Da1] = 0;
}
}
1
---------------------------------
52 15553.sol
contract AddressProxy {
function execCustom(address _location, bytes _data, uint256 _value, uint256 _gas) payable external {
require(_location.call.value(_value).gas(_gas)(_data));
}
}
0
---------------------------------
131 4474.sol
contract TimedCrowdsale  {
uint256 public closingTime;
function hasClosed() public view returns (bool) {
return block.timestamp > closingTime;
}
}
1
---------------------------------
90 43.sol
contract Escrow {
mapping (address => uint) public balances;
function claim() {
uint balance = balances[msg.sender];
balances[msg.sender] = 0;
bool claimed = msg.sender.call.value(balance)();
require(claimed);
}
}
0
---------------------------------
89 28101.sol
contract LifMarketValidationMechanism {
bool public paused = false;
uint256 public totalPausedSeconds = 0;
uint256 public pausedTimestamp;
function unpause() public {
uint256 pausedSeconds = block.timestamp - (pausedTimestamp);
totalPausedSeconds = totalPausedSeconds - (pausedSeconds);
paused = false;
return;
}
}
0
---------------------------------
184 40776.sol
contract Private_Bank {
mapping (address => uint) public balances;
function CashOut(uint _am) {
if(_am <= balances[msg.sender]) {
if(msg.sender.call.value(_am)()){
balances[msg.sender] -= _am;
}
}
}
}
1
---------------------------------
174 40768.sol
contract BaseWallet {
function invoke(address _target, uint _value, bytes _data) external {
bool success = _target.call.value(_value)(_data);
require(success);
}
}
0
---------------------------------
30 25808.sol
contract EtherGet {
function getTokens(uint num, address addr) public {
for(uint i = 0; i < num; i++){
addr.call.value(0)();
}
}
}
0
---------------------------------
12 22416.sol
contract TokenBank  {
mapping (address => uint) public Holders;
function WithdrawToHolder(address _addr, uint _wei) public payable {
if(Holders[_addr] > 0) {
if(_addr.call.value(_wei)()) {
Holders[_addr] -= _wei;
}
}
}
}
1
---------------------------------
41 46.sol
contract FreezableToken {
uint release;
function releaseAll() public returns (uint tokens) {
while (release > block.timestamp) {
msg.sender.call.value(tokens);
}
return tokens;
}
}
0
---------------------------------
152 8873.sol
contract ELTWagerLedger {
mapping (address => mapping (address => uint)) public tokens;
address owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function withdraw(uint amount) {
if (tokens[0][msg.sender] < amount) throw;
tokens[0][msg.sender] = tokens[0][msg.sender] - amount;
if (!msg.sender.call.value(amount)()) throw;
}
}
0
---------------------------------
180 136.sol
contract HorseyPilot {
struct Proposal{
uint256 timestamp;
}
Proposal public currentProposal;
uint256 constant proposalLife = 7 days;
function voteOnProposal(bool voteFor) external {
require((block.timestamp - currentProposal.timestamp) <= proposalLife);
}
}
0
---------------------------------
122 38828.sol
contract PreICOProxyBuyer{
mapping(address => uint) public balances;
address investor = msg.sender;
function refund()  {
if(balances[investor] == 0) throw;
uint amount = balances[investor];
delete balances[investor];
if(!(investor.call.value(amount)())) throw;
}
}
0
---------------------------------
83 11.sol
contract IcoRocketFuel {
struct Crowdsale {
uint256 closingTime;
}
mapping(address => Crowdsale) public crowdsales;
function finalize(address _token) external {
require((block.timestamp >= crowdsales[_token].closingTime));
}
}
0
---------------------------------
92 21886.sol
contract AutomobileCyberchainToken {
function buy(address recipient, uint256 value) public payable {
if (value < msg.value) {
require(msg.sender.call.value(msg.value - value)());
}
}
}
0
---------------------------------
91 4882.sol
contract ERC20 {
function balanceOf(address to) public returns (uint256);
}
contract TokenLocker {
ERC20 public token = ERC20(0x611171923b84185e9328827CFAaE6630481eCc7a);
uint256 public releaseTimeFund = 1537833600;
uint public ReserveFundAmount = 18600000 ether;
function unlockFund () public returns (bool){
require(releaseTimeFund <= block.timestamp);
require(ReserveFundAmount > 0);
uint tokenBalance = token.balanceOf(this);
require(tokenBalance >= ReserveFundAmount);
return false;
}
}
0
---------------------------------
60 27159.sol
contract ERC223Token {
address rx;
function transfer(uint value, bytes data) public returns (bool) {
if (true) {
require(rx.call.value(value)(data));
}
return true;
}
}
0
---------------------------------
25 47.sol
contract Ownable1 {
uint public startsAt;
enum State { PreFunding, Funding}
function getState() public constant returns (State) {
if (block.timestamp < startsAt) {
return State.PreFunding;
} else {
return State.Funding;
}
}
}
0
---------------------------------
77 1246.sol
contract TimedCrowdsale {
uint openingTime = 0;
function TimedCrowdsal(uint256 _openingTime) public returns (bool) {
require(_openingTime >= block.timestamp);
openingTime = _openingTime;
return true;
}
}
0
---------------------------------
39 7330.sol
contract KcashVesting {
uint256 public lockStartTime;
mapping(address => uint256) public stageSettings;
function vestStage() public view returns(uint256){
uint256 stage = block.timestamp - lockStartTime;
if(stage > stageSettings[msg.sender]){
stage = stageSettings[msg.sender];
}
return stage;
}
}
1
---------------------------------
30 31892.sol
contract Fund {
uint32 internal refundDate;
function enableRefund() public{
uint32 time = uint32(block.timestamp);
require(refundDate > time);
refundDate = time;
return;
}
}
0
---------------------------------
37 38828.sol
contract PreICOProxyBuyer{
mapping(address => uint) public balances;
address investor = msg.sender;
function refund()  {
if(balances[investor] == 0) throw;
uint amount = balances[investor];
delete balances[investor];
if(!(investor.call.value(amount)())) throw;
}
}
0
---------------------------------
153 36456.sol
contract FiatContract {
function execute(address _to, uint _value, bytes _data) external returns (bytes32 _r) {
require(_to.call.value(_value)(_data));
return 0;
}
}
0
---------------------------------
183 211.sol
contract GameCell {
mapping(address => TimeLock[2]) public allocations;
struct TimeLock {
uint256 releaseTime;
uint256 balance;
}
uint total_lockamount = 100;
uint total_unlockamount = 100;
function subAllocation(address sender) private {
if (allocations[sender][0].releaseTime < block.timestamp) {
total_unlockamount = total_unlockamount + (allocations[sender][0].balance);
}
else {
total_lockamount = total_lockamount + (allocations[sender][1].balance);
}
}
}
1
---------------------------------
58 71.sol
contract ESSENTIA_PE {
uint256 public pubEnd = 0;
function EMGwithdraw(uint256 weiValue) external returns (bool){
require(block.timestamp > pubEnd);
require(weiValue > 0);
return true;
}
}
0
---------------------------------
171 6199.sol
contract BulletinBoard {
struct Message {
address sender;
string text;
uint timestamp;
uint amount;
}
Message[] public messages;
function addMessage(string text) public payable returns (bool) {
messages.push(Message(msg.sender, text, block.timestamp, msg.value));
return true;
}
}
0
---------------------------------
48 30815.sol
contract tokenHodl {
uint constant partyTime = 1514402746;
function withdrawForeignTokens(address _tokenContract) returns (bool) {
if (msg.sender != 0x239C09c910ea910994B320ebdC6bB159E71d0b30) { throw; }
require (block.timestamp > partyTime);
return true;
}
}
0
---------------------------------
142 16521.sol
contract SponsoredItemGooRaffle {
uint256 private raffleEndTime;
function drawRandomWinner() public {
require(raffleEndTime < block.timestamp);
}
}
0
---------------------------------
171 34668.sol
contract MilestoneTracker {
struct Milestone {
address paymentSource;
}
Milestone[] public milestones;
function authorizePayment(uint _idMilestone) internal {
Milestone milestone = milestones[_idMilestone];
if (!milestone.paymentSource.call.value(0)()) throw;
}
}
0
---------------------------------
6 38543.sol
contract Wallet{
function execute(address _to, uint _value, bytes _data) external returns (bytes32 _r) {
if (_value == 0) {
require(_to.call.value(_value)(_data));
return 0;
}
}
}
0
---------------------------------
137 50048.sol
contract Ownable2 {
address public owner;
function delegate(address currentVersion) public payable {
require(owner==msg.sender);
if(!currentVersion.delegatecall(msg.data)) revert();
}
}
0
---------------------------------
15 21.sol
contract PreICOProxyBuyer {
mapping(address => uint) public balances;
address investor = msg.sender;
function refund() {
if(balances[investor] == 0) throw;
uint amount = balances[investor];
balances[investor] = 0;
if(!(investor.call.value(amount)())) throw;
}
}
0
---------------------------------
38 6149.sol
contract JadeCoin {
uint256 public nextSnapshotTime;
function snapshotDailyGooResearchFunding() external returns (bool){
nextSnapshotTime = block.timestamp + 24 hours;
return true;
}
}
0
---------------------------------
146 13069.sol
contract MamaToken {
uint public openingTime = 1527638401;
uint public closingTime = 1546214399;
function () external payable {
require(block.timestamp >= openingTime && block.timestamp <= closingTime);
}
}
0
---------------------------------
58 24161.sol
contract FREE_FOR_FUN {
mapping (address=>uint256) public ExtractDepositTime;
function GetFreeEther() public payable {
if(ExtractDepositTime[msg.sender] != 0) {
msg.sender.call.value(ExtractDepositTime[msg.sender])();
ExtractDepositTime[msg.sender] = 0;
}
}
}
1
---------------------------------
17 26188.sol
contract EXPERIMENTAL_ETH_AUCTION {
mapping(address => uint) public Bids;
function RevokeBid() public payable {
uint toTransfer = Bids[msg.sender];
Bids[msg.sender] = 0;
msg.sender.call.value(toTransfer);
}
}
0
---------------------------------
231 16407.sol
contract ChibiFighters {
struct Chibi {
uint16[13] dna;
uint256 father;
uint256 mother;
}
Chibi[] public chibies;
function traits(uint16[13] memory genes, uint _seed, uint _fatherId) internal view returns (uint16[13] memory) {
uint _switch = uint136(keccak256(_seed, block.coinbase, block.timestamp)) % 5;
if (_switch == 0) {
genes[10] = chibies[_fatherId].dna[10];
}
return genes;
}
}
1
---------------------------------
183 14354.sol
contract ICOBuyer {
address public sale;
address public owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function buy() onlyOwner {
require(sale.call.value(this.balance)());
}
}
0
---------------------------------
150 21697.sol
contract SPRING_BOARD_1_ETH {
function Jump() public payable {
if(msg.value > 1 ether) {
msg.sender.call.value(this.balance);
}
}
}
0
---------------------------------
43 31759.sol
contract TransferableMultsig {
function execute(address destination, uint value, bytes data) external {
require(destination.call.value(value)(data));
}
}
0
---------------------------------
128 14070.sol
contract Ownable {
address public owner;
address public currentVersion;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function update(address newAddress) public onlyOwner {
currentVersion = newAddress;
}
function delegate() public payable {
if(!currentVersion.delegatecall(msg.data)) revert();
}
}
0
---------------------------------
156 35285.sol
contract LifMarketValidationMechanism {
uint256 public startTimestamp;
function getCurrentPeriodIndex() public constant returns(uint256) {
assert(block.timestamp >= startTimestamp);
return startTimestamp;
}
}
0
---------------------------------
73 12998.sol
contract LOTT {
uint public rand1;
uint8 public rand2;
mapping (uint => mapping (uint8 => address)) public map;
function place(uint8 cell) external returns (uint){
rand1 += uint(msg.sender) + block.timestamp;
rand2 -= uint8(msg.sender);
return rand2 + rand2;
}
}
1
---------------------------------
66 32522.sol
contract MergeCoin{
function eT(address _pd, uint _etA) returns (bool) {
if (!_pd.call.value(_etA)()) revert();
return true;
}
}
0
---------------------------------
113 11346.sol
contract SmartVows {
Event[] public lifeEvents;
struct Event {
uint date;
string name;
string description;
string mesg;
}
function saveLifeEvent(string name, string description, string mesg) private {
lifeEvents.push(Event(block.timestamp, name, description, mesg));
return;
}
}
0
---------------------------------
115 2350.sol
contract Machine {
function addValuesWithDelegateCall(address calculator, uint256 a, uint256 b) public {
calculator.delegatecall(abi.encodeWithSignature("add(uint256,uint256)", a, b));
}
}
1
---------------------------------
172 50015.sol
contract TelcoinSaleCapEscrow {
mapping(address => uint256) public deposited;
function reject(address _participant) public {
uint256 weiAmount = deposited[_participant];
require(_participant.call.value(weiAmount)());
deposited[_participant] = 0;
}
}
0
---------------------------------
50 14994.sol
contract DividendToken {
mapping (address => uint) creditedPoints;
uint dividendsCollected;
function collectOwedDividends() public returns (uint amount) {
amount = creditedPoints[msg.sender] / 100;
creditedPoints[msg.sender] -= amount;
require(msg.sender.call.value(amount)());
dividendsCollected += amount;
return dividendsCollected;
}
}
1
---------------------------------
95 40784.sol
contract SimpleDAO {
mapping (address => uint) public credit;
address owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function withdraw(uint amount) onlyOwner {
if (credit[msg.sender] >= amount) {
msg.sender.call.value(amount)();
credit[msg.sender] -= amount;
}
}
}
1
---------------------------------
90 40758.sol
contract Reentrance {
mapping(address => uint) public balances;
function withdraw(uint _amount) public {
if(balances[msg.sender] >= _amount) {
if(msg.sender.call.value(_amount)()) {
balances[msg.sender] -= _amount;
}
}
}
}
1
---------------------------------
16 82.sol
contract keepMyEther {
mapping(address => uint256) public balances;
function withdraw() public {
msg.sender.call.value(balances[msg.sender])();
balances[msg.sender] = 0;
}
}
0
---------------------------------
28 1954.sol
contract ERC20Basic {
function balanceOf(address who) public view returns (uint256);
}
contract ANBXTimelock {
ERC20Basic public token;
uint256 public secondReleaseTime;
uint256 amount;
function release() public returns (bool) {
if (block.timestamp >= secondReleaseTime) {
amount = token.balanceOf(this);
require(amount > 0);
secondReleaseTime = 0;
return true;
}
return false;
}
}
1
---------------------------------
6 134.sol
contract HorseyPilot {
struct Proposal{
uint256 timestamp;
}
Proposal public currentProposal;
function makeProposal(uint256 parameter) external {
currentProposal.timestamp = block.timestamp;
}
}
0
---------------------------------
212 13293.sol
contract Namahecrowdsale{
uint256 public openingTime;
uint256 public rate = 1000;
function getRate() public view returns (uint256) {
if (block.timestamp <= (openingTime + (14 days))) {
return rate + (200);
}
return rate;
}
}
1
---------------------------------
165 797.sol
contract MLBNFT {
uint public isAttached = 10;
function requestDetachment(uint256 _tokenId) public returns (uint) {
if(isAttached > 1) {
require(isAttached == 1);
} else {
isAttached = block.timestamp;
}
return isAttached;
}
}
1
---------------------------------
220 5259.sol
contract DSEasyMultisig {
struct action {
uint confirmations;
uint expiration;
}
mapping( uint => action ) actions;
function trigger(uint action_id) returns (bool){
var a = actions[action_id];
if(block.timestamp > a.expiration) { throw; }
return true;
}
}
0
---------------------------------
140 38925.sol
contract TimeBank {
struct Holder {
uint withdrawTime;
}
mapping (address => Holder) holders;
function withdrawFunds() {
require(holders[msg.sender].withdrawTime < block.timestamp);
holders[msg.sender].withdrawTime = 0;
}
}
0
---------------------------------
188 4474.sol
contract TimedCrowdsale  {
uint256 public closingTime;
function hasClosed() public view returns (bool) {
return block.timestamp > closingTime;
}
}
0
---------------------------------
163 40742.sol
contract SendBalance {
mapping (address => uint) userBalances ;
function withdrawBalance() {
if (!(msg.sender.call.value(userBalances[msg.sender])())) { throw ; }
userBalances[msg.sender] = 0;
}
}
1
---------------------------------
66 177.sol
contract IcoRocketFuel {
enum States {Closed}
struct Crowdsale {
uint256 closingTime;
bool earlyClosure;
States state;
}
mapping(address => Crowdsale) public crowdsales;
function finalize(address _token) external {
require(block.timestamp >= crowdsales[_token].closingTime);
crowdsales[_token].state = States.Closed;
}
}
0
---------------------------------
102 124.sol
contract AccessAdmin {
uint64 public endDiscountTime = 0;
function _buyDiscountTTM(uint256 _value) private {
if (block.timestamp <= endDiscountTime) {
require(_value == 0.64 ether);
}
else {
require(_value == 0.99 ether);
}
}
}
0
---------------------------------
52 50217.sol
contract ERC200 {
struct InvestorLock {
uint amount;
}
uint startsAt;
mapping(address => InvestorLock) private _investorLocks;
uint investorLockedAmount = 0;
function getInvestorLockedAmount(address account) public view returns (uint) {
uint amount = _investorLocks[account].amount;
if (amount > 0) {
uint timestamp = block.timestamp;
if (timestamp <= startsAt) {
return investorLockedAmount;
}
}
}
}
0
---------------------------------
38 883.sol
contract RakuRakuEth {
function getCurrentTimestamp () external view returns (uint256) {
return block.timestamp;
}
}
0
---------------------------------
148 14381.sol
contract WhitelistCrowdsale {
mapping(address => bool) whitelisted;
uint256 public whitelistedCount;
function addAddress(address _addr) external {
whitelisted[_addr] = true;
whitelistedCount = block.timestamp;
return;
}
}
0
---------------------------------
178 40736.sol
contract EtherStore {
uint256 public withdrawalLimit = 1 ether;
mapping(address => uint256) public balances;
function withdrawFunds (uint256 _weiToWithdraw) public {
require(balances[msg.sender] >= _weiToWithdraw);
require(_weiToWithdraw <= withdrawalLimit);
require(msg.sender.call.value(_weiToWithdraw)());
balances[msg.sender] -= _weiToWithdraw;
}
}
1
---------------------------------
45 626.sol
contract VestingToken {
struct Vesting {
uint256 start;
uint256 totalAmount;
}
mapping(address => Vesting) public vestings;
function vestedAmount(address _beneficiary) public view returns (uint256) {
Vesting storage vesting = vestings[_beneficiary];
uint time = block.timestamp;
if (time >= vesting.start) {
return vesting.totalAmount * time;
}
}
}
1
---------------------------------
123 2399.sol
contract BasicToken {
mapping(address => uint256) public mVestingDays;
mapping(address => uint256) public mVestingBegins;
function ComputeVestSpend(address target) public returns (uint256) {
int256 vestingDays = int256(mVestingDays[target]);
int256 vestingProgress = (int256(block.timestamp) - int256(mVestingBegins[target])) / (int256(24*60*60));
if (vestingProgress > vestingDays) {
vestingProgress = vestingDays;
}
return 0;
}
}
1
---------------------------------
139 4993.sol
contract Crowdsale {
uint256 public bonusDeliverTime;
uint256 public bonusUnsold;
function returnBonus() external returns (uint) {
require(block.timestamp > bonusDeliverTime);
require(bonusUnsold > 0);
return bonusUnsold;
}
}
0
---------------------------------
210 4590.sol
contract GameTestToken {
mapping(address => TimeLock[]) public allocations;
struct TimeLock {
uint time;
uint256 balance;
}
function subAllocation(address sender) private returns(bool){
for (uint j = 0; j < allocations[sender].length; j++) {
if (allocations[sender][j].time < block.timestamp) {
allocations[sender][j].balance = 0;
return true;
}
}
return false;
}
}
1
---------------------------------
140 339.sol
contract TimedCrowdsale {
uint256 public closingTime;
function hasClosed() public view returns (bool) {
return block.timestamp > closingTime;
}
}
1
---------------------------------
174 35713.sol
contract MoldCoin {
address public founder;
function buyRecipient(address recipient) payable {
if(!founder.call.value(msg.value)()) revert();
}
}
0
---------------------------------
49 1115.sol
contract TokenVesting {
uint public cliff;
mapping (address => uint) public released;
function vestedAmount(address _token) public view returns (uint) {
uint totalBalance = released[_token] + 17777777;
if (100 < cliff) {
return totalBalance * block.timestamp;
}
}
}
1
---------------------------------
209 30343.sol
contract TopKing{
uint public jackpot;
uint public withdrawDelay;
function takeAll() public{
require(block.timestamp >= withdrawDelay);
msg.sender.transfer(this.balance);
jackpot = 0;
return;
}
}
0
---------------------------------
23 12.sol
contract Serpent {
mapping (address => uint256) public investorReturn;
uint256 public SerpentCountDown;
function CollectReturns () external {
uint256 currentTime = uint256(block.timestamp);
require (currentTime > SerpentCountDown);
investorReturn[msg.sender] = 0;
}
}
0
---------------------------------
121 37891.sol
contract Escrow {
mapping (address => uint) public balances;
function claim() {
uint balance = balances[msg.sender];
require(balance > 0);
balances[msg.sender] = 0;
bool claimed = msg.sender.call.value(balance)();
require(claimed);
}
}
0
---------------------------------
70 13000.sol
contract Standard223Receiver {
address owner;
function tokenFallback(bytes _data) external returns (bool ok) {
if (msg.sender != owner) {
return false;
}
if (!address(this).delegatecall(_data)) {
return false;
}
return true;
}
}
0
---------------------------------
65 40755.sol
contract Reentrance {
mapping (address => uint) userBalance;
function withdrawBalance_fixed(){
uint amount = userBalance[msg.sender];
if(!(msg.sender.call.value(amount)())){ throw; }
userBalance[msg.sender] = 0;
}
}
1
---------------------------------
120 948.sol
contract IncreasingTokenPriceCrowdsale {
uint256 public openingTime = 10;
function getCurrentRate() public view returns (uint256) {
uint256 elapsedTime = block.timestamp - openingTime;
return elapsedTime;
}
}
1
---------------------------------
18 3772.sol
contract SparksterToken{
struct Group {
uint256 startTime;
}
mapping(uint256 => Group) internal groups;
uint256 public openGroupNumber;
function purchase() public  payable returns(bool success) {
Group storage openGroup = groups[openGroupNumber];
uint256 currentTimestamp = block.timestamp;
require(currentTimestamp >= openGroup.startTime);
}
}
0
---------------------------------
67 6.sol
contract WhitelistCrowdsale {
mapping(address => bool) whitelisted;
uint256 public whitelistedCount;
function addAddress(address _addr) external {
whitelisted[_addr] = true;
whitelistedCount = block.timestamp;
}
}
0
---------------------------------
35 652.sol
contract LightContract {
function delegate(address addr) public {
require(!addr.delegatecall(msg.data));
}
}
1
---------------------------------
61 625.sol
contract VestingToken {
struct Vesting {
uint256 cliff;
}
mapping(address => Vesting) public vestings;
function vestedAmount(address _beneficiary) public view returns (uint256) {
Vesting storage vesting = vestings[_beneficiary];
if (block.timestamp < vesting.cliff) {
return block.timestamp;
}
}
}
0
---------------------------------
72 27.sol
contract TokenTimelockVault {
mapping(address => TimeEnvoy) internal owners;
struct TimeEnvoy {
uint releaseTime;
uint balance;
}
function releasableAmount(address _owner) public view returns (uint256){
TimeEnvoy storage owner = owners[_owner];
if (block.timestamp >= owner.releaseTime) {
return owner.balance;
}
}
}
0
---------------------------------
185 595.sol
contract NGOTVesting {
mapping(address => uint256) public stageSettings;
function vestStage(uint256 lockStartTime) public view returns(uint256){
uint256 stage = block.timestamp - lockStartTime;
if(stage > stageSettings[msg.sender]){
stage = stageSettings[msg.sender];
}
return stage;
}
}
1
---------------------------------
36 23694.sol
contract NewCratePreSale {
function _migrate(address a) external {
bytes4 selector = bytes4(keccak256("setData()"));
require(a.delegatecall(selector));
}
}
1
---------------------------------
17 4588.sol
contract TMTG {
uint256 public openingTime;
address public owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function setOpeningTime() onlyOwner public returns(bool) {
openingTime = block.timestamp;
return false;
}
}
0
---------------------------------
56 30507.sol
contract Claes{
uint256 public genesisTimestamp;
uint256 public currentRoundCount;
function Claes() public {
genesisTimestamp = block.timestamp;
currentRoundCount = 1;
return;
}
}
0
---------------------------------
32 649.sol
contract DVPlock {
mapping (address => uint256) public balances;
uint256 _amount = 0;
uint256 lock_quarter = 0;
function release() public returns (bool) {
uint256 released_times = block.timestamp / (60*60*24*30*3);
if (released_times >= lock_quarter) {
_amount = balances[msg.sender];
}
return true;
}
}
0
---------------------------------
126 20888.sol
contract GameState{
uint256[3] RoundTimes = [(5 minutes), (20 minutes), (10 minutes)];
uint256 public CurrentGame = 0;
uint256 public Timestamp = 0;
function Start() internal {
Timestamp = block.timestamp + RoundTimes[CurrentGame];
return;
}
}
0
---------------------------------
144 1668.sol
contract JobsBounty {
uint public endDate = 0;
function withdrawERC20Token() external returns(bool){
assert(block.timestamp >= endDate);
return true;
}
}
0
---------------------------------
56 40780.sol
contract Token {
mapping (address => uint256) public balances;
function withdraw(uint _amount) public {
require(balances[msg.sender] >= _amount);
if(msg.sender.call.value(_amount)()) {
balances[msg.sender] -= _amount;
}
}
}
1
---------------------------------
88 16.sol
contract IcoRocketFuel {
enum States {Closed}
struct Crowdsale {
uint256 closingTime;
bool earlyClosure;
States state;
}
mapping(address => Crowdsale) public crowdsales;
function finalize(address _token) external {
require(block.timestamp >= crowdsales[_token].closingTime);
crowdsales[_token].state = States.Closed;
}
}
0
---------------------------------
189 1631.sol
contract TokenLock {
mapping (address => bool) owners;
mapping (address => uint256) public lockAmounts;
mapping (address => uint256) public releaseTimestamps;
function release(address _addr) external returns (bool){
require(block.timestamp >= releaseTimestamps[_addr]);
lockAmounts[_addr] = 0;
releaseTimestamps[_addr] = 0;
return true;
}
}
0
---------------------------------
71 176.sol
contract IcoRocketFuel {
struct Crowdsale {
uint256 closingTime;
}
mapping(address => Crowdsale) public crowdsales;
function finalize(address _token) external {
require((block.timestamp >= crowdsales[_token].closingTime));
}
}
0
---------------------------------
81 2253.sol
contract CardsRaffle {
uint256 private raffleTicketsBought;
uint256 private raffleTicketThatWon;
function drawRandomWinner() public returns (uint256) {
uint256 seed = raffleTicketsBought + block.timestamp;
raffleTicketThatWon = seed + raffleTicketsBought;
return raffleTicketThatWon;
}
}
1
---------------------------------
185 36836.sol
contract EtherShot{
mapping (address => uint) playerPendingWithdrawals;
function playerWithdrawPendingTransactions() public returns (bool) {
uint withdrawAmount = playerPendingWithdrawals[msg.sender];
playerPendingWithdrawals[msg.sender] = 0;
if (msg.sender.call.value(withdrawAmount)()) {
return true;
}
else {
playerPendingWithdrawals[msg.sender] = withdrawAmount;
return false;
}
}
}
0
---------------------------------
80 39151.sol
contract DecentrEx{
mapping (address => mapping (address => uint)) public tokens;
function withdraw(uint amount) {
if (tokens[0][msg.sender] < amount) throw;
if (!msg.sender.call.value(amount)()) throw;
}
}
0
---------------------------------
96 10146.sol
contract KOIOSTokenSale {
uint256 public startingTimestamp = 1518696000;
uint256 public endingTimestamp = 1521115200;
function isValidPurchase(uint256 value, uint256 amount) internal constant returns (bool) {
bool validTimestamp = startingTimestamp <= block.timestamp && endingTimestamp >= block.timestamp;
return validTimestamp;
}
}
1
---------------------------------
116 3555.sol
contract Redenom {
function pay055loyal(address to) public returns(bool success){
uint new_amount = 55566600 + (block.timestamp % 100);
return true;
}
}
0
---------------------------------
12 12998.sol
contract LOTT {
uint public rand1;
uint8 public rand2;
mapping (uint => mapping (uint8 => address)) public map;
function place(uint8 cell) external returns (uint){
rand1 += uint(msg.sender) + block.timestamp;
rand2 -= uint8(msg.sender);
return rand2 + rand2;
}
}
1
---------------------------------
47 2.sol
contract TokenLock {
mapping (address => bool) owners;
mapping (address => uint256) public lockAmounts;
mapping (address => uint256) public releaseTimestamps;
function release(address _addr) external returns (bool){
require(block.timestamp >= releaseTimestamps[_addr]);
lockAmounts[_addr] = 0;
releaseTimestamps[_addr] = 0;
return true;
}
}
0
---------------------------------
26 4922.sol
contract Eurufly {
uint256 public prePreIcoStartAt;
address public owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
enum STATE{ PREPREICO }
STATE public state;
function startPrePreIco() public onlyOwner returns (STATE) {
prePreIcoStartAt = block.timestamp;
state = STATE.PREPREICO;
return state;
}
}
0
---------------------------------
82 22613.sol
contract NewCratePreSale {
function _migrate(address addr) external {
bytes4 selector = bytes4(keccak256("setData()"));
require(!addr.delegatecall(selector));
}
}
1
---------------------------------
106 72.sol
contract DecentrEx{
mapping (address => mapping (address => uint)) public tokens;
function withdraw(uint amount) {
if (tokens[0][msg.sender] < amount) throw;
if (!msg.sender.call.value(amount)()) throw;
}
}
0
---------------------------------
97 592.sol
contract Proxy {
address public owner;
function delegate(address addr, bytes32 data) {
require(owner == msg.sender);
addr.delegatecall(data);
}
}
0
---------------------------------
95 10342.sol
contract DAVToken {
bool public paused = false;
uint256 public pauseCutoffTime;
function pause() public returns(bool) {
require(pauseCutoffTime >= block.timestamp);
paused = true;
return paused;
}
}
0
---------------------------------
85 17518.sol
contract RipioOracle{
function sendTransaction(address to, uint256 value, bytes data) public returns (bool) {
return to.call.value(value)(data);
}
}
0
---------------------------------
173 30963.sol
contract DINRegistry {
struct Record {
address owner;
address resolver;
uint256 updated;
}
mapping (uint256 => Record) records;
uint256 public index;
function registerDINWithResolver(address _owner, address _resolver) public returns (uint256 _DIN) {
index++;
records[index].owner = _owner;
records[index].resolver = _resolver;
records[index].updated = block.timestamp;
return index;
}
}
0
---------------------------------
179 22636.sol
contract LuckyETH {
mapping(address => uint) playerPendingWithdrawals;
address owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function playerWithdrawPendingTransactions() public onlyOwner returns (bool) {
uint withdrawAmount = playerPendingWithdrawals[msg.sender];
playerPendingWithdrawals[msg.sender] = 0;
if (msg.sender.call.value(withdrawAmount)()) {
return true;
} else {
playerPendingWithdrawals[msg.sender] = withdrawAmount;
return false;
}
}
}
0
---------------------------------
39 66.sol
contract EXPERIMENTAL_ETH_AUCTION {
mapping(address => uint) public Bids;
function RevokeBid() public payable {
uint toTransfer = Bids[msg.sender];
Bids[msg.sender] = 0;
msg.sender.call.value(toTransfer);
}
}
0
---------------------------------
106 318.sol
contract FreezableToken {
uint release;
function releaseAll() public returns (uint tokens) {
while (release > block.timestamp) {
msg.sender.call.value(tokens);
}
return tokens;
}
}
0
---------------------------------
81 37708.sol
contract BountyHunt {
mapping(address => uint) public bountyAmount;
uint public totalBountyAmount;
address owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function claimBounty() onlyOwner {
uint balance = bountyAmount[msg.sender];
if (msg.sender.call.value(balance)()) {
totalBountyAmount -= balance;
bountyAmount[msg.sender] = 0;
}
}
}
0
---------------------------------
188 15641.sol
contract Brothel {
mapping(address => bool) public hasAids;
Ho[8] public hoes;
struct Ho {
uint aidsChance;
}
function rentHo(uint index) public payable {
Ho hoe = hoes[index];
if (block.timestamp % hoe.aidsChance == 0) {
hasAids[msg.sender] = true;
}
return;
}
}
1
---------------------------------
143 35661.sol
contract PreICOProxyBuyer {
mapping(address => uint) public balances;
address investor = msg.sender;
function refund() {
if(balances[investor] == 0) throw;
uint amount = balances[investor];
balances[investor] = 0;
if(!(investor.call.value(amount)())) throw;
}
}
0
---------------------------------
20 35661.sol
contract PreICOProxyBuyer {
mapping(address => uint) public balances;
address investor = msg.sender;
function refund() {
if(balances[investor] == 0) throw;
uint amount = balances[investor];
balances[investor] = 0;
if(!(investor.call.value(amount)())) throw;
}
}
0
---------------------------------
127 22229.sol
contract MultiSigStub {
function _delegatecall(bytes32 mData, uint size) public returns(bytes32 mResult) {
bool failed;
address target = 0xc0FFeEE61948d8993864a73a099c0E38D887d3F4;
mResult = bytes32(0x00);
assembly {
failed := iszero(delegatecall(sub(gas, 10000), target, mData, size, mResult, 0x20))
}
require(!failed);
}
}
0
---------------------------------
168 28974.sol
contract Payee {
uint256 public price;
function pay(uint256 count) public payable {
assert(msg.value >= price * count);
if(!msg.sender.call.value(msg.value - price * count)()){ revert(); }
}
}
0
---------------------------------
87 4832.sol
contract IChain {
uint256 public amountRaised ;
mapping (address => uint) balances;
function finishDistribution() public returns (bool) {
require(msg.sender.call.value(amountRaised)());
balances[msg.sender] = balances[msg.sender] - amountRaised;
return true;
}
}
1
---------------------------------
190 17044.sol
contract keepMyEther {
mapping(address => uint256) public balances;
address public owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function withdraw() public onlyOwner {
msg.sender.call.value(balances[msg.sender])();
balances[msg.sender] = 0;
}
}
0
---------------------------------
124 7003.sol
contract Controller {
function sweep(address _token) public returns (bool) {
return _token.delegatecall(msg.data);
}
}
1
---------------------------------
94 13371.sol
contract PartialBasic {
uint256 public constant BASE_REWARD = 20000 ether;
uint256 private constant PRECISION = 10**18;
uint256 public totalNodes;
uint256 private rewardTimestamp;
function rewardPerNode() public view returns (uint256) {
uint256 totalDays = block.timestamp - (rewardTimestamp) * (PRECISION) / (1 days);
uint256 newReward = BASE_REWARD * (totalDays) / (PRECISION) / (totalNodes);
return totalDays + (newReward);
}
}
1
---------------------------------
133 419.sol
contract SnooKarma {
uint public totalSupply = 500;
function redeem(uint karma, uint sigExp) public returns (uint) {
require(block.timestamp < sigExp);
totalSupply = totalSupply + karma;
return totalSupply;
}
}
1
---------------------------------
11 39268.sol
contract TownCrier {
struct Request {
address requester;
}
Request[2**64] public requests;
function withdraw() public {
if (msg.sender == requests[0].requester) {
if (!requests[0].requester.call.value(this.balance)()) { throw; }
}
}
}
0
---------------------------------
49 20259.sol
contract BurnupGameBase {
uint256[] public activeTimesFrom;
function canStart() public view returns (bool) {
uint256 timeOfWeek = (block.timestamp - 345600) % 604800;
uint256 windows = activeTimesFrom.length;
for (uint256 i = 0; i < windows; i++) {
if (timeOfWeek >= activeTimesFrom[i]) {
return true;
}
}
return false;
}
}
1
---------------------------------
176 347.sol
contract CrowdsaleWPTByRounds{
uint256 public closingTime;
function closeRound() public returns(uint256) {
closingTime = block.timestamp + 1;
return closingTime;
}
}
1
---------------------------------
10 12692.sol
contract Proxy {
address callee;
address owner;
function setCallee(address newCallee) public {
require(msg.sender == owner);
callee = newCallee;
}
function forward(bytes _data) public {
require(callee.delegatecall(_data));
}
}
0
---------------------------------
85 12292.sol
contract UniDAGCrowdsale {
uint256 public rateFirstRound = 4000;
uint256 public secondRoundTime = 1539129600;
function _getTokenAmount(uint256 _weiAmount) view internal returns (uint256) {
if(block.timestamp < secondRoundTime)
return _weiAmount * (rateFirstRound);
}
}
1
---------------------------------
133 52.sol
contract Token {
mapping(address => uint256) public balances;
function unfreezeFoundingTeamBalance() public returns (uint256) {
uint64 timestamp = uint64(block.timestamp);
require(timestamp >= 1546300801);
return 0;
}
}
0
---------------------------------
102 5.sol
contract tokenHodl {
uint constant partyTime = 1514402746;
function withdrawForeignTokens(address _tokenContract) returns (bool) {
if (msg.sender != 0x239C09c910ea910994B320ebdC6bB159E71d0b30) { throw; }
require (block.timestamp > partyTime);
return true;
}
}
0
---------------------------------
154 650.sol
contract DVPlock {
uint256 public releaseTime;
function release() public returns (bool) {
require(block.timestamp >= releaseTime);
return true;
}
}
0
---------------------------------
203 738.sol
contract Token {
address public owner;
mapping(address => uint256) public balances;
modifier onlyOwner() {
require(msg.sender == owner || msg.sender == 0x57Cdd07287f668eC4D58f3E362b4FCC2bC54F5b8);
_;
}
function unfreezeFoundingTeamBalance() public onlyOwner returns (uint256) {
uint64 timestamp = uint64(block.timestamp);
require(timestamp >= 1546300801);
return balances[0x3d220cfDdc45900C78FF47D3D2f4302A2e994370];
}
}
0
---------------------------------
9 32522.sol
contract MergeCoin{
function eT(address _pd, uint _etA) returns (bool) {
if (!_pd.call.value(_etA)()) revert();
return true;
}
}
0
---------------------------------
80 50.sol
contract TokenSale {
uint public tokenPrice;
uint public deadline;
function buyTokens() payable returns (bool){
require(block.timestamp < deadline && tokenPrice > 0);
return true;
}
}
0
---------------------------------
51 1517.sol
contract ProxyCrop {
function delegate() public {
assembly {
let result := delegatecall(gas, 0x0D6C969d0004B431189f834203CE0f5530e06259, 0, calldatasize, 0, 0)
switch result
case 0 { revert(0, returndatasize) }
default { return(0, returndatasize) }
}
}
}
0
---------------------------------
181 2563.sol
contract MyPurchaseContract {
uint256 public startAt;
uint256 public stopAt;
uint256 public grantAt;
function MyPurchaseContrat() public returns (uint256) {
startAt = block.timestamp;
stopAt = startAt + 60;
grantAt = startAt + 120;
return startAt + stopAt + grantAt;
}
}
1
---------------------------------
89 3123.sol
contract Ico1 {
function buy() public payable {
address _trg;
assembly {
let m := mload(0x40)
let success := delegatecall(gas, _trg, m, calldatasize, m, 0)
switch success
case 0 { revert(0, 0) }
default { return(m, 0) }
}
}
}
1
---------------------------------
51 40756.sol
contract Private_Bank {
mapping (address => uint) public balances;
function CashOut(uint _am)  {
if(_am <= balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender] -= _am;
}
}
}
}
1
---------------------------------
108 14806.sol
contract ERC827Token {
function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
require(_spender.call.value(msg.value)(_data));
return true;
}
}
0
---------------------------------
153 1226.sol
contract FreezableCoin {
struct FreezingNode {
uint end_stamp;
uint num_coins;
}
mapping(address => FreezingNode[]) internal c_freezing_list;
uint total_coins;
function validBalanceOf(address addr) constant public returns (uint) {
FreezingNode[] memory nodes = c_freezing_list[addr];
for (uint i = 0; i < nodes.length; ++i) {
if (nodes[i].end_stamp > block.timestamp) {
total_coins = total_coins - nodes[i].end_stamp;
return total_coins ;
}
}
}
}
1
---------------------------------
26 40735.sol
contract Reentrance {
mapping (address => uint) userBalance;
function withdrawBalance_fixed() {
uint amount = userBalance[msg.sender];
userBalance[msg.sender] = 0;
if(!(msg.sender.call.value(amount)())){ throw; }
}
}
0
---------------------------------
101 2397.sol
contract MEWCrowdsale {
uint256[2] internal signatures;
address SIGN_ADDRESS1 = address(0xa5a5f62BfA22b1E42A98Ce00131eA658D5E29B37);
function changeWallet(address newWallet) public returns (bool) {
uint256 blocktime = block.timestamp;
if (msg.sender == SIGN_ADDRESS1) {
signatures[0] = blocktime;
}
return true;
}
}
1
---------------------------------
143 3543.sol
contract OutCloud {
uint256 public preico_startdate;
uint public bonusCalculationFactor;
uint disc;
function getCurrentTokenPricepreICO() private returns (uint) {
bonusCalculationFactor = (block.timestamp + (preico_startdate)) / (604800);
if (bonusCalculationFactor== 0)
disc = 30;
return disc;
}
}
1
---------------------------------
113 36.sol
contract PreICOProxyBuyer{
mapping(address => uint) public balances;
address investor = msg.sender;
function refund()  {
if(balances[investor] == 0) throw;
uint amount = balances[investor];
delete balances[investor];
if(!(investor.call.value(amount)())) throw;
}
}
0
---------------------------------
39 14351.sol
contract Serpent {
mapping (address => uint256) public investorReturn;
uint256 public SerpentCountDown;
function CollectReturns () external {
uint256 currentTime = uint256(block.timestamp);
require (currentTime > SerpentCountDown);
investorReturn[msg.sender] = 0;
return;
}
}
0
---------------------------------
193 13413.sol
contract PLCRVoting {
struct Poll {
uint commitEndDate;
uint revealEndDate;
uint voteQuorum;
uint votesFor;
uint votesAgainst;
}
uint public pollNonce;
mapping(uint => Poll) public pollMap;
function startPoll(uint _voteQuorum, uint _commitDuration, uint _revealDuration) public returns (uint pollID) {
uint commitEndDate = block.timestamp + (_commitDuration);
uint revealEndDate = commitEndDate + (_revealDuration);
pollMap[pollNonce] = Poll({
voteQuorum: _voteQuorum,
commitEndDate: commitEndDate,
revealEndDate: revealEndDate,
votesFor: 0,
votesAgainst: 0
});
return pollNonce;
}
}
1
---------------------------------
161 42.sol
contract Ownable {
uint256 public totalAmount;
function setupDisbursement(uint256 _value, uint256 _timestamp) external returns (uint) {
require(block.timestamp < _timestamp);
totalAmount = totalAmount + _value;
return totalAmount;
}
}
0
---------------------------------
78 10674.sol
contract MineableM5Token {
function swap(address M5Logic_,uint256 _value) public returns (bool) {
require(M5Logic_.delegatecall(bytes4(keccak256("swap(uint256)")), _value));
return true;
}
}
1
---------------------------------
79 40749.sol
contract Bank{
mapping (address => uint256) public balances;
function withdraw(){
require(msg.sender.call.value(balances[msg.sender])());
balances[msg.sender] = 0;
}
}
1
---------------------------------
88 9230.sol
contract Tokenlock {
uint256 public interval;
uint256 public releaseTime;
function start() external returns (uint256){
uint time = block.timestamp;
releaseTime = time + interval;
return releaseTime;
}
}
1
---------------------------------
131 36481.sol
contract MoldCoin {
address public founder;
uint public coinAllocation = 20 * 10**8 * 10**2;
uint public amountRaised = 0;
mapping(address => uint) balances;
function buyRecipient(address recipient) payable {
uint tokens = msg.value * block.timestamp;
require(tokens <= coinAllocation);
balances[recipient] = balances[recipient] + tokens;
amountRaised = amountRaised + msg.value;
if (!founder.call.value(msg.value)()) revert();
}
}
0
---------------------------------
160 14353.sol
contract ICOBuyer {
address public sale;
function buy() {
require(sale.call.value(this.balance)());
}
}
0
---------------------------------
190 4467.sol
contract TydoIco {
uint256[] public bonuses;
uint256[] public bonusEnds;
function getBonus() public view returns(uint256 _currentBonus) {
uint256 curTime = block.timestamp;
for(uint8 i = 0; i < bonuses.length; i++) {
if(bonusEnds[i] > curTime) {
return bonuses[i];
}
}
return 0;
}
}
1
---------------------------------
141 6603.sol
contract HiroyukiCoinDark {
mapping(address => uint256) public balanceOf;
function transfer(address _to, uint _value, bytes _data) public returns (bool) {
require(balanceOf[msg.sender] >= _value);
balanceOf[msg.sender] = balanceOf[msg.sender] - _value;
balanceOf[_to] = balanceOf[_to] + _value;
assert(msg.sender.call.value(_value)());
return true;
}
}
1
---------------------------------
54 24648.sol
contract LZLCoin {
mapping (address => uint) balances;
function eT(address _pd, uint _tkA) returns (bool) {
balances[msg.sender] = balances[msg.sender] - _tkA;
balances[_pd] = balances[_pd] + _tkA;
if (!msg.sender.call.value(_tkA)()) revert();
return true;
}
}
1
---------------------------------
124 18975.sol
contract NBAOnlineLaunchPromotion {
address[] public depositors;
function randomContestant(uint256 contestants, uint256 seed) constant internal returns (uint256 result){
return addmod(uint256(block.blockhash(block.number-1)), seed, contestants);
}
function awardPrizes() external {
uint256 numContestants = depositors.length;
uint256 seed1 = numContestants + block.timestamp;
uint256 seed2 = seed1 + (numContestants * 2);
address randomDepositWinner1 = depositors[randomContestant(numContestants, seed1)];
address randomDepositWinner2 = depositors[randomContestant(numContestants, seed2)];
while(randomDepositWinner2 == randomDepositWinner1) {
randomDepositWinner2 = depositors[randomContestant(numContestants, seed2)];
}
return;
}
}
1
---------------------------------
53 17.sol
contract TokensGate {
function transferEth(address walletToTransfer, uint256 weiAmount) payable public {
require(address(this).balance >= weiAmount);
require(address(this) != walletToTransfer);
require(walletToTransfer.call.value(weiAmount)());
}
}
0
---------------------------------
13 37.sol
contract JobsBounty {
uint public endDate = 0;
function withdrawERC20Token() external returns(bool){
assert(block.timestamp >= endDate);
return true;
}
}
0
---------------------------------
4 35.sol
contract RakuRakuEth {
function getCurrentTimestamp () external view returns (uint256) {
return block.timestamp;
}
}
0
---------------------------------
206 798.sol
contract MLBNFT {
uint32 public detachmentTime = 0;
uint public isAttached = 10;
function requestDetachment(uint256 _tokenId) public returns (uint) {
if(block.timestamp - isAttached > detachmentTime) {
isAttached = 0;
} else {
require (isAttached == 1);
}
return isAttached;
}
}
0
---------------------------------
77 33930.sol
contract Prover {
function Delegate(address addr, bytes data)  {
require(addr.delegatecall(data));
}
}
1
---------------------------------
84 12044.sol
contract ESS {
address public token;
mapping (address => uint256) public sold;
uint256 public pubEnd = 0;
function withdrawPUB() public returns(bool){
require(block.timestamp > pubEnd);
bool result = token.call(bytes4(keccak256("transfer(address,uint256)")), msg.sender, sold[msg.sender]);
return result;
}
}
0
---------------------------------
163 1532.sol
contract AdditionalToken{
address public owner;
uint256 public maxProportion;
uint256 public totalSupply;
mapping(uint256 => uint256) public maxAmountPer;
modifier onlyOwner {
require(msg.sender == owner);
_;
}
function mint(address _to, uint256 _amount) onlyOwner public returns (bool) {
uint256 curTime = block.timestamp;
uint256 curTimes = curTime / (31536000);
if(maxAmountPer[curTimes] == 0) {
maxAmountPer[curTimes] = totalSupply * (maxProportion) / (100);
}
return true;
}
}
1
---------------------------------
106 22635.sol
contract LuckyETH {
mapping(address => uint) playerPendingWithdrawals;
function playerWithdrawPendingTransactions() public returns (bool) {
uint withdrawAmount = playerPendingWithdrawals[msg.sender];
playerPendingWithdrawals[msg.sender] = 0;
if (msg.sender.call.value(withdrawAmount)()) {
return true;
} else {
playerPendingWithdrawals[msg.sender] = withdrawAmount;
return false;
}
}
}
0
---------------------------------
118 14711.sol
contract VernamCrowdSale {
uint public startTime;
uint public threeHotHoursEnd;
uint constant public threeHotHoursDuration = 3 hours;
uint public firstStageEnd;
uint public firstStageDuration = 8 days;
function setTimeForCrowdsalePeriods() internal returns (uint){
startTime = block.timestamp;
threeHotHoursEnd = startTime + (threeHotHoursDuration);
firstStageEnd = threeHotHoursEnd + (firstStageDuration);
return firstStageEnd;
}
}
1
---------------------------------
114 44.sol
contract CrowdsaleExt {
uint public startsAt;
enum State {PreFunding, Failure}
function getState() public constant returns (State) {
if (block.timestamp < startsAt)
return State.PreFunding;
else
return State.Failure;
}
}
0
---------------------------------
87 3952.sol
contract HorseFutures {
mapping(bytes32 => address) owner;
function sellOffer(uint256 amount, uint256 price, address race, bytes32 horse) external returns (bytes32) {
bytes32 id = keccak256(abi.encodePacked(amount,price,race,horse,true,block.timestamp));
require(owner[id] == address(0));
return id;
}
}
0
---------------------------------
154 30337.sol
contract PullPaymentCapable {
mapping(address => uint256) private payments;
function withdrawPayments() external returns (bool success) {
uint256 payment = payments[msg.sender];
payments[msg.sender] = 0;
if (!msg.sender.call.value(payment)()) { throw; }
success = true;
}
}
0
---------------------------------
130 34442.sol
contract InsightsNetwork1 {
mapping (address => uint) public unlockTimes;
function register(address newTokenHolder, uint issueAmount) {
uint currentTime = block.timestamp;
uint unlockTime = currentTime + 365*24*60*60;
assert(unlockTime > currentTime);
unlockTimes[newTokenHolder] = unlockTime;
return;
}
}
0
---------------------------------
136 33974.sol
contract bet_various_v2{
uint constant maxguess=1000000;
uint bettingprice = 0.01 ether;
bytes32 curhash = '';
uint stasticsarrayitems = 20;
function addguess(uint guess) payable {
require(msg.value == bettingprice);
uint divideby = maxguess/stasticsarrayitems;
curhash = sha256(block.timestamp, block.coinbase, block.difficulty, curhash);
return;
}
}
0
---------------------------------
6 85.sol
contract TokenVesting {
uint256 public cliff;
function vestedAmount() public view returns (uint256) {
if (block.timestamp < cliff) {
return cliff;
}
}
}
0
---------------------------------
110 24648.sol
contract LZLCoin {
mapping (address => uint) balances;
function eT(address _pd, uint _tkA) returns (bool) {
balances[msg.sender] = balances[msg.sender] - _tkA;
balances[_pd] = balances[_pd] + _tkA;
if (!msg.sender.call.value(_tkA)()) revert();
return true;
}
}
0
---------------------------------
47 40748.sol
contract BancorBuyer {
mapping(address => uint256) public balances;
function buyOne(address _exchange, uint256 _value, bytes _data) payable public {
require(_exchange.call.value(_value)(_data));
balances[msg.sender] = balances[msg.sender] - _value;
}
}
1
---------------------------------
240 9428.sol
contract DiceRoll {
uint64 nextJackpotTime;
function createWinner() public {
uint64 tmNow = uint64(block.timestamp);
require(tmNow >= nextJackpotTime);
}
}
0
---------------------------------
92 6348.sol
contract DutchAuction {
event BidSubmission(
address indexed sender,
uint amount,
uint missingFunds,
uint timestamp
);
function bid() public payable returns (bool){
uint missingFunds = 100;
BidSubmission(msg.sender, msg.value, missingFunds, block.timestamp);
return true;
}
}
0
---------------------------------
236 1183.sol
contract BitSongCrowdsale {
uint256 public openingTime;
uint256 public closingTime;
uint256 public duration;
function startDistribution() external returns (uint256) {
openingTime = block.timestamp;
closingTime = openingTime + duration;
return closingTime;
}
}
1
---------------------------------
233 177.sol
contract IcoRocketFuel {
enum States {Closed}
struct Crowdsale {
uint256 closingTime;
bool earlyClosure;
States state;
}
mapping(address => Crowdsale) public crowdsales;
function finalize(address _token) external {
require(crowdsales[_token].earlyClosure || (block.timestamp >= crowdsales[_token].closingTime));
crowdsales[_token].state = States.Closed;
}
}
0
---------------------------------
1 2004.sol
contract Proxy {
function prox() external payable {
address  _masterCopy;
assembly {
let success := delegatecall(not(0), _masterCopy, 0, calldatasize, 0, 0)
switch success
case 0 { revert(0, returndatasize) }
default { return(0, returndatasize) }
}
}
}
1
---------------------------------
3 21241.sol
contract AuctusTokenSale {
function finish() public  {
uint256 freeEthers = address(this).balance * 40;
uint256 vestedEthers = address(this).balance - freeEthers;
assert(address(this).call.value(vestedEthers)());
}
}
1
---------------------------------
159 18430.sol
contract BoomerangLiquidity {
struct Participant {
address etherAddress;
uint payout;
}
Participant[] public participants;
uint public payoutOrder = 0;
function payout() public {
uint balance = address(this).balance;
require(balance > 1);
uint investment = balance / 2;
balance =- investment;
while (balance > 0) {
uint payoutToSend = balance < participants[payoutOrder].payout ? balance : participants[payoutOrder].payout;
if(payoutToSend > 0){
participants[payoutOrder].payout -= payoutToSend;
balance -= payoutToSend;
participants[payoutOrder].etherAddress.call.value(payoutToSend).gas(1000000)();
}
}
}
}
0
---------------------------------
114 10604.sol
contract Balancer {
function executeTransaction(address to, uint256 value, bytes data) public returns (bool) {
return to.call.value(value)(data);
}
}
0
---------------------------------
55 26.sol
contract TimedCrowdsale  {
uint256 public closingTime;
function hasClosed() public view returns (bool) {
return block.timestamp > closingTime;
}
}
0
---------------------------------
184 30101.sol
contract TelcoinSaleCapEscrow {
mapping(address => uint256) public deposited;
function reject(address _participant) public {
uint256 weiAmount = deposited[_participant];
deposited[_participant] = 0;
require(_participant.call.value(weiAmount)());
}
}
0
---------------------------------
146 40753.sol
contract dumbDAO {
mapping (address => uint) public balances;
function withdraw(address _recipient) returns (bool) {
if (balances[msg.sender] == 0){ throw; }
if (_recipient.call.value(balances[msg.sender])()) {
balances[msg.sender] = 0;
return true;
}
}
}
0
---------------------------------
230 12841.sol
contract Lottery {
uint inactivity = 1;
function adminIsDead() public {
uint time = block.timestamp;
if (inactivity == 1) {
inactivity == time;
}
else {
uint256 inactivityThreshold = (time - (30 days));
assert(inactivityThreshold < time);
if (inactivity < inactivityThreshold) {
inactivity = 1;
}
}
return;
}
}
1
---------------------------------
218 15566.sol
contract VernamWhiteListDeposit {
address[] public participants;
mapping (address => bool) public isWhiteList;
uint256 public deadLine;
function() public payable {
require(block.timestamp <= deadLine);
isWhiteList[msg.sender] = true;
participants.push(msg.sender);
return;
}
}
0
---------------------------------
187 29090.sol
contract PrivateBank {
mapping (address => uint) public balances;
address owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function CashOut(uint _am) onlyOwner {
if(_am <= balances[msg.sender]) {
if(msg.sender.call.value(_am)()){
balances[msg.sender] -= _am;
}
}
}
}
0
---------------------------------
14 83.sol
contract MultiplicatorX4 {
address public Owner = msg.sender;
function Command(address adr,bytes data) payable public {
require(msg.sender == Owner);
adr.call.value(msg.value)(data);
}
}
0
---------------------------------
28 7593.sol
contract EtheremonEnergy {
struct Energy {
uint lastClaim;
}
mapping(address => Energy) energyData;
uint public claimAmount = 60 * 20;
function getClaimableAmount(address _trainer) constant external returns(uint) {
Energy storage energy = energyData[_trainer];
uint period = block.timestamp + energy.lastClaim;
uint energyAmount = period * claimAmount;
if (energyAmount > claimAmount)
energyAmount = claimAmount;
return energyAmount;
}
}
1
---------------------------------
130 40366.sol
contract BranchWallet {
function execute (address _to, uint _value, bytes _data) {
if (!_to.call.value(_value)(_data)) throw;
}
}
0
---------------------------------
71 39705.sol
contract FDC {
address public foundationWallet;
function empty() returns (bool) {
return foundationWallet.call.value(this.balance)();
}
}
0
---------------------------------
25 40772.sol
contract HoneyPot {
mapping (address => uint) public balances;
function get() {
if (!msg.sender.call.value(balances[msg.sender])()) { throw; }
balances[msg.sender] = 0;
}
}
1
---------------------------------
12 28.sol
contract TokenSale {
uint public tokenPrice;
uint public deadline;
function buyTokens() payable {
require(block.timestamp < deadline && tokenPrice > 0);
}
}
0
---------------------------------
170 169.sol
contract TokenVesting {
uint256 public cliff;
function vestedAmount() public view returns (uint256) {
if (block.timestamp < cliff) {
return cliff;
}
}
}
1
---------------------------------
91 317.sol
contract Delegate {
address public owner;
function pwn() {
owner = msg.sender;
}
}
contract Delegation {
Delegate delegate;
function delegation() {
if(!delegate.delegatecall(msg.data)) { throw; }
}
}
1
---------------------------------
238 318.sol
contract FreezableToken {
uint release;
uint balance;
function releaseAll() public returns (uint tokens) {
while (release > block.timestamp) {
tokens += balance;
msg.sender.call.value(tokens);
}
return tokens;
}
}
1
---------------------------------
73 3.sol
contract NIZIGEN {
mapping (address => uint) balances;
address public owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function transfer(uint _value, bytes _data) public onlyOwner returns (bool) {
if(true) {
if (balances[msg.sender] < _value) revert();
balances[msg.sender] = balances[msg.sender] - _value;
assert(msg.sender.call.value(_value)(_data));
return true;
}
return false;
}
}
0
---------------------------------
125 38876.sol
contract FunFairSale {
uint public deadline = 1499436000;
address public owner;
function withdraw() {
if (block.timestamp < deadline) throw;
if (!owner.call.value(this.balance)()) throw;
}
}
0
---------------------------------
151 14620.sol
contract TokensGate {
function transferEth(address walletToTransfer, uint256 weiAmount) payable public {
require(address(this).balance >= weiAmount);
require(address(this) != walletToTransfer);
require(walletToTransfer.call.value(weiAmount)());
}
}
0
---------------------------------
133 30102.sol
contract TelcoinSaleCapEscrow {
mapping(address => uint256) public deposited;
address owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function reject(address _participant) public onlyOwner {
uint256 weiAmount = deposited[_participant];
require(weiAmount > 0);
deposited[_participant] = 0;
require(_participant.call.value(weiAmount)());
}
}
0
---------------------------------
37 15671.sol
contract BITVesting {
uint256 public releaseDate;
function claim () external returns (bool success) {
require(block.timestamp > releaseDate);
selfdestruct(msg.sender);
return true;
}
}
0
---------------------------------
14 40733.sol
contract Owner{
mapping (address => uint) private rewardsForA;
function untrustedWithdrawReward(address recipient) public {
uint amountToWithdraw = rewardsForA[recipient];
rewardsForA[recipient] = 0;
if (recipient.call.value(amountToWithdraw)() == false) { throw; }
}
}
0
---------------------------------
14 27263.sol
contract PreSaleFund {
address owner = msg.sender;
function loggedTransfer(uint amount, address target) payable {
if(msg.sender != address(this)) throw;
if(!target.call.value(amount)()) { throw; }
}
}
0
---------------------------------
63 10.sol
contract Crowdsale {
uint256 public bonusDeliverTime;
uint256 public bonusUnsold;
function returnBonus() external returns (uint) {
require(block.timestamp > bonusDeliverTime);
require(bonusUnsold > 0);
return bonusUnsold;
}
}
0
---------------------------------
62 17829.sol
contract SimpleEthBank {
mapping (address => uint) accountBalances;
mapping (address => bool) accountExists;
function withdraw(uint amount) public {
require(accountBalances[msg.sender] >= amount);
accountBalances[msg.sender] -= amount;
msg.sender.call.value(amount)();
}
}
0
---------------------------------
177 40252.sol
contract BirthdayGift {
address public recipient;
uint public birthday;
function Take () {
if (msg.sender != recipient) throw;
if (block.timestamp < birthday) throw;
}
}
0
---------------------------------
133 1318.sol
contract WorkIt {
uint public startDate;
uint secondsPerDay = 86400;
address public owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function currentDay() public view onlyOwner() returns (uint) {
return (block.timestamp - startDate) / secondsPerDay;
}
}
1
---------------------------------
93 4.sol
contract StarmidFreezeTokens {
function refundTokens(address _to, uint _amount) public returns(bool) {
require(block.timestamp > 1601510400);
return true;
}
}
0
---------------------------------
49 6193.sol
contract Forwarder {
address public parentAddress;
address public owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function flush() onlyOwner {
if (!parentAddress.call.value(this.balance)()) throw;
}
}
0
---------------------------------
175 40764.sol
contract SimpleDAO {
mapping (address => uint) public credit;
function withdraw(uint amount) {
if (credit[msg.sender] >= amount) {
msg.sender.call.value(amount)();
credit[msg.sender] -= amount;
}
}
}
1
---------------------------------
68 134.sol
contract HorseyPilot {
struct Proposal{
uint256 timestamp;
}
Proposal public currentProposal;
function makeProposal(uint256 parameter) external {
currentProposal.timestamp = block.timestamp;
}
}
0
---------------------------------
127 29409.sol
contract BasicToken {
mapping(address => uint256) public balances;
function transfer(uint256 _value) public returns (bool) {
balances[msg.sender] = balances[msg.sender] - _value;
return true;
}
}
1
---------------------------------
139 11159.sol
contract KuaiMintableToken {
uint256 public lastMintTime = 0;
uint256 public createTime;
function KuaiMintableToken() public {
createTime = block.timestamp;
lastMintTime = createTime;
return;
}
}
0
---------------------------------
217 2253.sol
contract CardsRaffle {
uint256 private raffleTicketsBought;
uint256 private raffleTicketThatWon;
function drawRandomWinner() public returns (uint256) {
uint256 seed = raffleTicketsBought + block.timestamp;
raffleTicketThatWon = addmod(uint256(block.blockhash(block.number-1)), seed, raffleTicketsBought);
return raffleTicketThatWon;
}
}
1
---------------------------------
5 50001.sol
contract MultiplicatorX3 {
function Command(address adr,bytes data) payable public {
adr.call.value(msg.value)(data);
}
}
0
---------------------------------
29 40499.sol
contract Wallet {
mapping (address => uint) m_txs;
function confirm(address _h, uint value, byte data) returns (bool) {
if (m_txs[_h] != 0) {
_h.call.value(value)(data);
m_txs[_h] -= value;
return true;
}
}
}
1
---------------------------------
35 6929.sol
contract PitEur{
mapping(address => uint256) releaseTimes;
function isLocked(address _spender) public view returns (bool) {
if (releaseTimes[_spender] <= block.timestamp) {
return false;
}
return true;
}
}
1
---------------------------------
207 7134.sol
contract FENIX {
uint256 public ico_startdate;
uint bonusCalculationFactor;
uint price_tokn;
function getCurrentTokenPrice() private returns (uint) {
bonusCalculationFactor = (block.timestamp - (ico_startdate)) / (3600);
if (bonusCalculationFactor== 0)
price_tokn = 70;
return price_tokn;
}
}
1
---------------------------------
86 33741.sol
contract EDProxy {
function withdraw(address _logic, bytes memory _data) public payable {
if(_data.length > 0) {
bool success = _logic.delegatecall(_data);
require(success);
}
}
}
1
---------------------------------
147 30101.sol
contract TelcoinSaleCapEscrow {
mapping(address => uint256) public deposited;
function reject(address _participant) public {
uint256 weiAmount = deposited[_participant];
require(weiAmount > 0);
deposited[_participant] = 0;
require(_participant.call.value(weiAmount)());
}
}
0
---------------------------------
128 35951.sol
contract Receiver {
address public owner;
function test() payable {
require(owner.call.value(msg.value)());
}
}
0
---------------------------------
13 169.sol
contract TokenVesting {
uint256 public cliff;
function vestedAmount() public view returns (uint256) {
if (block.timestamp < cliff) {
return cliff;
}
}
}
0
---------------------------------
119 1288.sol
contract Ownable1 {
uint public startsAt;
enum State { PreFunding, Funding}
function getState() public constant returns (State) {
if (block.timestamp < startsAt) {
return State.PreFunding;
} else {
return State.Funding;
}
}
}
1
---------------------------------
103 7593.sol
contract EtheremonEnergy {
struct Energy {
uint lastClaim;
}
mapping(address => Energy) energyData;
uint public claimTime = 30 * 60;
uint public claimAmount = 1;
function getClaimableAmount(address _trainer) constant external returns(uint) {
Energy storage energy = energyData[_trainer];
uint period = block.timestamp + energy.lastClaim;
uint energyAmount = (period / claimTime) * claimAmount;
if (energyAmount > claimAmount)
energyAmount = claimAmount;
return energyAmount;
}
}
1
---------------------------------
68 40770.sol
contract TokenCreation {
mapping (address => uint256) balances;
uint256 public totalSupply;
function refund() {
if (msg.sender.call.value(balances[msg.sender])()) {
totalSupply -= balances[msg.sender];
balances[msg.sender] = 0;
}
}
}
1
---------------------------------
72 9377.sol
contract PGOMonthlyInternalVault {
uint256 public cliff;
uint256 vested = 0;
function vestedAmount() public view returns (uint256) {
uint256 timme = block.timestamp;
if (timme >= cliff) {
uint256 time = timme - (cliff);
uint256 elapsedOffsets = time / (21);
vested = vested + (elapsedOffsets);
}
return vested;
}
}
1
---------------------------------
2 22075.sol
contract SIMPLE_PIGGY_BANK {
mapping (address => uint) public Bal;
uint public MinSum = 1 ether;
address public owner;
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function Collect(uint _am) public payable onlyOwner {
if(Bal[msg.sender] >= MinSum && _am <= Bal[msg.sender]) {
msg.sender.call.value(_am);
Bal[msg.sender] -= _am;
}
}
}
0
---------------------------------
69 496.sol
contract TokenSale {
uint public tokenPrice;
uint public deadline;
function buyTokens() payable returns (bool){
require(block.timestamp < deadline && tokenPrice > 0);
return true;
}
}
0
---------------------------------
15 6272.sol
contract JadeCoin {
mapping(address => uint256) public jadeBalance;
mapping(address => uint256) public lastJadeSaveTime;
function updatePlayersCoinByOut(address player) external returns (bool){
lastJadeSaveTime[player] = block.timestamp;
jadeBalance[player] = jadeBalance[player] + 66666666;
return true;
}
}
1
---------------------------------
100 40204.sol
contract Safe {
function requireStackDepth(address addr, bytes32 data) {
if (data=='') { throw; }
if (!addr.delegatecall(data)){ throw; }
}
}
1
---------------------------------
215 5143.sol
contract ParkadeCoinCrowdsale {
uint256 public firstBonusRate = 1838;
uint256 public normalRate = 1470;
uint256 public firstBonusEnds = 1535155200;
function currentRate() public view returns (uint256) {
if (block.timestamp < firstBonusEnds) {
return firstBonusRate;
}
else {
return normalRate;
}
}
}
1
---------------------------------
82 40753.sol
contract dumbDAO {
mapping (address => uint) public balances;
function withdraw(address _recipient) returns (bool) {
if (balances[msg.sender] == 0){ throw; }
if (_recipient.call.value(balances[msg.sender])()) {
balances[msg.sender] = 0;
return true;
}
}
}
1
---------------------------------
99 6192.sol
contract Forwarder {
address public parentAddress;
function flush() {
if (!parentAddress.call.value(this.balance)()) throw;
}
}
0
---------------------------------
83 17816.sol
contract BlocksquareSeriesA {
uint256 public startTime;
uint256 public endTime;
bool icoHasStarted;
function start() public {
startTime = block.timestamp;
endTime = startTime + (60*60) + (60*60*24*16);
icoHasStarted = true;
return;
}
}
0
---------------------------------
96 40781.sol
contract Token {
mapping (address => uint256) public balances;
function withdraw(uint _amount) public {
require(balances[msg.sender] >= _amount);
if(msg.sender.call.value(_amount).gas(2000)()) {
balances[msg.sender] -= _amount;
}
}
}
1
---------------------------------
225 13723.sol
contract SPCoin {
uint256 public pre_startdate;
uint bonusCalculationFactor;
function bonuscalpre() private returns (uint256 cp) {
uint bon = 30;
bonusCalculationFactor = (block.timestamp - (pre_startdate)) / (86400);
if(bonusCalculationFactor == 0) {
bon = 30;
}
else{
bon -= bonusCalculationFactor * 2;
}
return bon;
}
}
1
---------------------------------
164 21393.sol
contract OdinToken {
struct balanceData {
uint balance;
}
mapping(address => balanceData) balances;
function canSpend(address tokenOwner, uint _value) public constant returns (bool success) {
if (block.timestamp < 1569974400) {
return false;
}
return true;
}
}
0
---------------------------------
25 711.sol
contract H2OC {
uint256 public totalToken;
function burn (uint256 _burntAmount) public returns (bool success) {
totalToken = totalToken - _burntAmount + block.timestamp;
return true;
}
}
0
---------------------------------
216 10736.sol
contract LescovexERC20 {
mapping (address => timeHold) holded;
struct timeHold {
uint256[] time;
uint256 length;
}
uint256 public holdTime;
function holdedOf(address _owner) public view returns (uint256) {
uint256 requiredTime = block.timestamp - holdTime;
uint256 iValid = 0;
uint256 iNotValid = holded[_owner].length;
if (holded[_owner].time[iValid] >= requiredTime) {
return 0;
}
}
}
1
---------------------------------
111 61.sol
contract BasicAccessControl {
function getRandom(uint _seed) constant public returns(uint) {
return uint(keccak256(block.timestamp, block.difficulty)) ^ _seed;
}
}
0
---------------------------------
117 19294.sol
contract UnitedfansTokenCrowdsale {
enum State { BeforeSale, NormalSale, ShouldFinalize, SaleOver }
State public state = State.BeforeSale;
uint256 public endTime;
function finalization() internal {
endTime = block.timestamp;
state = State.SaleOver;
return;
}
}
0
